# frozen_string_literal: true
# typed: true

module SorbetRBIGeneration; end

require_relative './module'

require 'set'

class SorbetRBIGeneration::RbiSerializer
  SPECIAL_METHOD_NAMES = %w[! ~ +@ ** -@ * / % + - << >> & | ^ < <= => > >= == === != =~ !~ <=> [] []= `]

  # These methods don't match the signatures of their parents, so if we let
  # them monkeypatch, they won't be subtypes anymore. Just don't support the
  # bad monkeypatches.
  BAD_METHODS = [
    ['activesupport', 'Time', :to_s],
    ['activesupport', 'Time', :initialize],
  ]

  def initialize(trace_results)
    @files = trace_results[:files]
    @delegate_classes = trace_results[:delegate_classes]

    @anonymous_map = {}
    @prev_anonymous_id = 0

  end

  def serialize(output_dir)
    grouped = {}
    used = {} # subclassed, included, or extended
    @files.each do |path, defined|
      gem = gem_from_location(path)
      if gem.nil?
        warn("Can't find gem for #{path}")
        next
      end
      next if gem[:gem] == 'ruby'

      grouped[gem] ||= {}
      defined.each do |item|
        klass = item[:module]
        klass_id = SorbetRBIGeneration::Module.real_object_id(klass)
        values = grouped[gem][klass_id] ||= []
        values << item unless item[:type] == :module

        # only add an anon module if it's used as a superclass of a non-anon module, or is included/extended by a non-anon module
        used_value = SorbetRBIGeneration::Module.real_is_a?(klass, Module) && !SorbetRBIGeneration::Module.real_name(klass).nil? ? true : SorbetRBIGeneration::Module.real_object_id(klass) # if non-anon, set it to true, otherwise link to next anon class
        (used[SorbetRBIGeneration::Module.real_object_id(klass.superclass)] ||= Set.new) << used_value if SorbetRBIGeneration::Module.real_is_a?(klass, Class)
        (used[item[item[:type]].object_id] ||= Set.new) << used_value if [:extend, :include].include?(item[:type])
      end
    end

    require 'fileutils'
    FileUtils.mkdir_p(output_dir)

    grouped.each do |gem, klass_ids|
      File.open("#{File.join(output_dir, gem[:gem])}.rbi", 'w') do |f|
        f.write("# AUTOGENERATED GEM RBI\n")
        f.write("# Run `srb init` to regenerate this file\n")
        f.write("# #{gem[:gem]}-#{gem[:version]}\n")
        f.write("# typed: true\n")
        klass_ids.each do |klass_id, defined|
          klass = ObjectSpace._id2ref(klass_id)

          next if !((SorbetRBIGeneration::Module.real_is_a?(klass, Module) && !SorbetRBIGeneration::Module.real_name(klass).nil?) || used?(klass_id, used))
          next if SorbetRBIGeneration::Module.real_is_a?(klass, Class) && klass.superclass == Delegator && !klass.name

          # next if [Object, BasicObject, Hash].include?(klass) # TODO should this be here?

          f.write("#{SorbetRBIGeneration::Module.real_is_a?(klass, Class) ? 'class' : 'module'} #{class_name(klass)}")
          f.write(" < #{class_name(klass.superclass)}") if SorbetRBIGeneration::Module.real_is_a?(klass, Class) && ![Object, nil].include?(klass.superclass)
          f.write("\n")

          rows = defined.map do |item|
            case item[:type]
            when :method
              if !valid_method_name?(item[:method])
                warn("Invalid method name: #{klass}.#{item[:method]}")
                next
              end
              if BAD_METHODS.include?([gem[:gem], class_name(klass), item[:method]])
                next
              end
              begin
                method = item[:singleton] ? klass.method(item[:method]) : klass.instance_method(item[:method])
                "#{generate_method(method, !item[:singleton])}"
              rescue NameError
              end
            when :include, :extend
              name = class_name(item[item[:type]])
              "  #{item[:type]} #{name}"
            end
          end
          rows = rows.compact.sort
          f.write(rows.join("\n"))
          f.write("\n") if !rows.empty?
          f.write("end\n")
        end
      end
    end
  end

  private

  def generate_method(method, instance, spaces = 2)
    # method.parameters is an array of:
    # a      [:req, :a]
    # b = 1  [:opt, :b]
    # c:     [:keyreq, :c]
    # d: 1   [:key, :d]
    # *e     [:rest, :e]
    # **f    [:keyrest, :f]
    # &g     [:block, :g]
    prefix = ' ' * spaces
    parameters = method.parameters.map.with_index do |(type, name), index|
      name = "arg#{index}" if name.nil? || name.empty?
      case type
      when :req
        name
      when :opt
        "#{name} = nil"
      when :keyreq
        "#{name}:"
      when :key
        "#{name}: nil"
      when :rest
        "*#{name}"
      when :keyrest
        "**#{name}"
      when :block
        "&#{name}"
      else
        raise "Unknown parameter type: #{type}"
      end
    end
    parameters = parameters.join(', ')
    parameters = "(#{parameters})" unless parameters.empty?
    "#{prefix}def #{instance ? '' : 'self.'}#{method.name}#{parameters}; end"
  end

  def anonymous_id
    @prev_anonymous_id += 1
  end

  def gem_from_location(location)
    match =
      location&.match(/^.*\/(ruby)\/([\d.]+)\//) || # ruby stdlib
      location&.match(/^.*\/(site_ruby)\/([\d.]+)\//) || # rubygems
      location&.match(/^.*\/gems\/[\d.]+(?:\/bundler)?\/gems\/([^\/]+)-([^-\/]+)\//i) # gem
    if match.nil?
      # uncomment to generate files for methods outside of gems
      # {
      #   path: location,
      #   gem: location.gsub(/[\/\.]/, '_'),
      #   version: '1.0.0',
      # }
      nil
    else
      {
        path: match[0],
        gem: match[1],
        version: match[2],
      }
    end
  end

  def class_name(klass)
    klass = @delegate_classes[SorbetRBIGeneration::Module.real_object_id(klass)] || klass
    name = SorbetRBIGeneration::Module.real_name(klass) if SorbetRBIGeneration::Module.real_is_a?(klass, Module)

    # class/module has no name; it must be anonymous
    if name.nil? || name == ""
      middle = SorbetRBIGeneration::Module.real_is_a?(klass, Class) ? klass.superclass : klass.class
      id = @anonymous_map[SorbetRBIGeneration::Module.real_object_id(klass)] ||= anonymous_id
      return "Anonymous_#{class_name(middle).gsub('::', '_')}_#{id}"
    end

    # if the name doesn't only contain word characters and ':', or any part doesn't start with a capital, Sorbet doesn't support it
    if name !~ /^[\w:]+$/ || !name.split('::').all? { |part| part =~ /^[A-Z]/ }
      warn("Invalid class name: #{name}")
      id = @anonymous_map[SorbetRBIGeneration::Module.real_object_id(klass)] ||= anonymous_id
      return "InvalidName_#{name.gsub(/[^\w]/, '_').gsub(/0x([0-9a-f]+)/, '0x00')}_#{id}"
    end

    name
  end

  def used?(klass, used)
    used_by = used[klass] || []
    used_by.any? { |user| user == true || used?(user, used) }
  end

  def valid_method_name?(symbol)
    string = symbol.to_s
    return true if SPECIAL_METHOD_NAMES.include?(string)
    string =~ /^[[:word:]]+[?!=]?$/
  end
end

