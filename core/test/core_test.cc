#include "doctest.h"
// has to go first as it violates our requirements
#include "core/Error.h"
#include "core/ErrorQueue.h"
#include "core/GlobalSubstitution.h"
#include "core/Unfreeze.h"
#include "core/core.h"
#include "core/errors/internal.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/spdlog.h"

namespace spd = spdlog;
using namespace std;

namespace sorbet::core {
auto logger = spd::stderr_color_mt("parse");
auto errorQueue = make_shared<ErrorQueue>(*logger, *logger);

struct Offset2PosTest {
    string src;
    u4 off;
    u4 line;
    u4 col;
};

TEST_CASE("TestOffset2Pos") {
    GlobalState gs(errorQueue);
    gs.initEmpty();
    UnfreezeFileTable fileTableAccess(gs);

    vector<Offset2PosTest> cases = {{"hello", 0, 1, 1},
                                    {"line 1\nline 2", 1, 1, 2},
                                    {"line 1\nline 2", 7, 2, 1},
                                    {"line 1\nline 2", 11, 2, 5},
                                    {"a long line with no newlines\n", 20, 1, 21},
                                    {"line 1\nline 2\nline3\n", 7, 2, 1},
                                    {"line 1\nline 2\nline3", 6, 1, 7},
                                    {"line 1\nline 2\nline3", 7, 2, 1}};
    int i = 0;
    for (auto &tc : cases) {
        auto name = string("case: ") + to_string(i);
        INFO(name);
        FileRef f = gs.enterFile(move(name), tc.src);

        auto detail = Loc::offset2Pos(f.data(gs), tc.off);

        CHECK_EQ(tc.col, detail.column);
        CHECK_EQ(tc.line, detail.line);
        i++;
    }
}

TEST_CASE("Errors") {
    GlobalState gs(errorQueue);
    gs.initEmpty();
    UnfreezeFileTable fileTableAccess(gs);
    FileRef f = gs.enterFile(string("a/foo.rb"), string("def foo\n  hi\nend\n"));
    if (auto e = gs.beginError(Loc{f, 0, 3}, errors::Internal::InternalError)) {
        e.setHeader("Use of metavariable: `{}`", "foo");
    }
    REQUIRE(gs.hadCriticalError());
    auto errors = errorQueue->drainAllErrors();
    REQUIRE_EQ(1, errors.size());
}

TEST_CASE("SymbolRef") {
    GlobalState gs(errorQueue);
    gs.initEmpty();
    SymbolRef ref = Symbols::Object();
    CHECK_EQ(ref, ref.data(gs)->ref(gs));
}

struct FileIsTypedCase {
    string_view src;
    StrictLevel strict;
};

TEST_CASE("FileIsTyped") { // NOLINT
    vector<FileIsTypedCase> cases = {
        {"", StrictLevel::None},
        {"# typed: true", StrictLevel::True},
        {"\n# typed: true\n", StrictLevel::True},
        {"not a typed: sigil\n# typed: true\n", StrictLevel::True},
        {"typed:\n# typed: nonsense\n", StrictLevel::None},
        {"# typed: strict\n", StrictLevel::Strict},
        {"# typed: strong\n", StrictLevel::Strong},
        {"# typed: autogenerated\n", StrictLevel::Autogenerated},
        {"# typed: false\n", StrictLevel::False},
        {"# typed: lax\n", StrictLevel::None},
        {"# typed: ignore\n", StrictLevel::Ignore},
        {"#    typed:      true\n", StrictLevel::True},
        {"typed: true\n", StrictLevel::None},

        // We no longer support the old sigil
        {"# @typed", StrictLevel::None},
        {"\n# @typed\n", StrictLevel::None},
    };
    for (auto &tc : cases) {
        CHECK_EQ(tc.strict, File::fileSigil(tc.src));
    }
}

TEST_CASE("Substitute") { // NOLINT
    GlobalState gs1(errorQueue);
    gs1.initEmpty();

    GlobalState gs2(errorQueue);
    gs2.initEmpty();

    NameRef foo1, bar1, other1;
    NameRef foo2, bar2;
    {
        UnfreezeNameTable thaw1(gs1);
        UnfreezeNameTable thaw2(gs2);

        foo1 = gs1.enterNameUTF8("foo");
        bar1 = gs1.enterNameUTF8("bar");
        other1 = gs1.enterNameUTF8("other");

        foo2 = gs2.enterNameUTF8("foo");
        gs1.enterNameUTF8("name");
        bar2 = gs1.enterNameUTF8("bar");
    }

    GlobalSubstitution subst(gs1, gs2);

    CHECK_EQ(subst.substitute(foo1), foo2);
    CHECK_EQ(subst.substitute(bar1), bar2);

    auto other2 = subst.substitute(other1);
    REQUIRE(other2.exists());
    REQUIRE(other2.data(gs2)->kind == NameKind::UTF8);
    REQUIRE_EQ("<U other>", other2.showRaw(gs2));
}
} // namespace sorbet::core
