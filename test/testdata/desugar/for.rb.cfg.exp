digraph "for.rb" {
subgraph "cluster_::<Class:<root>>#<static-init>" {
    label = "::<Class:<root>>#<static-init>";
    color = blue;
    "bb::<Class:<root>>#<static-init>_0" [shape = invhouse];
    "bb::<Class:<root>>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:<root>>#<static-init>_0" [
        label = "block[id=0]()\l<U <self>>: T.class_of(<root>) = cast(<U <self>>: NilClass, T.class_of(<root>));\l<U <statTemp>>$5: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$6: T.class_of(A) = alias <C <U A>>\l<U <statTemp>>$4: Sorbet::Private::Static::Void = <U <statTemp>>$5: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$6: T.class_of(A))\l<U <statTemp>>$9: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$10: T.class_of(E) = alias <C <U E>>\l<U <statTemp>>$8: Sorbet::Private::Static::Void = <U <statTemp>>$9: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$10: T.class_of(E))\l<U <statTemp>>$13: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$14: T.class_of(Main) = alias <C <U Main>>\l<U <statTemp>>$12: Sorbet::Private::Static::Void = <U <statTemp>>$13: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$14: T.class_of(Main))\l<U <statTemp>>$16: T.class_of(Main) = alias <C <U Main>>\l<U <statTemp>>$15: T.untyped = <U <statTemp>>$16: T.class_of(Main).<U main>()\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_1" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
}

subgraph "cluster_::<Class:A>#each" {
    label = "::<Class:A>#each";
    color = blue;
    "bb::<Class:A>#each_0" [shape = invhouse];
    "bb::<Class:A>#each_1" [shape = parallelogram];

    "bb::<Class:A>#each_0" [
        label = "block[id=0]()\l<U <self>>: T.class_of(A) = cast(<U <self>>: NilClass, T.class_of(A));\l<U <blk>>: T.untyped = load_arg(A.each#<blk>)\l<U <statTemp>>$5: Integer(1) = 1\l<U <statTemp>>$6: Integer(2) = 2\l<U <statTemp>>$7: Integer(3) = 3\l<U <statTemp>>$8: Integer(4) = 4\l<U <statTemp>>$9: Integer(5) = 5\l<U <statTemp>>$3: T.untyped = <U <blk>>: T.untyped.<U call>(<U <statTemp>>$5: Integer(1), <U <statTemp>>$6: Integer(2), <U <statTemp>>$7: Integer(3), <U <statTemp>>$8: Integer(4), <U <statTemp>>$9: Integer(5))\l<U <statTemp>>$11: Integer(6) = 6\l<U <statTemp>>$12: Integer(7) = 7\l<U <statTemp>>$13: Integer(8) = 8\l<U <statTemp>>$14: Integer(9) = 9\l<U <statTemp>>$15: Integer(0) = 0\l<U <returnMethodTemp>>$2: T.untyped = <U <blk>>: T.untyped.<U call>(<U <statTemp>>$11: Integer(6), <U <statTemp>>$12: Integer(7), <U <statTemp>>$13: Integer(8), <U <statTemp>>$14: Integer(9), <U <statTemp>>$15: Integer(0))\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:A>#each_0" -> "bb::<Class:A>#each_1" [style="bold"];
    "bb::<Class:A>#each_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:A>#each_1" -> "bb::<Class:A>#each_1" [style="bold"];
}

subgraph "cluster_::<Class:E>#e=" {
    label = "::<Class:E>#e=";
    color = blue;
    "bb::<Class:E>#e=_0" [shape = invhouse];
    "bb::<Class:E>#e=_1" [shape = parallelogram];

    "bb::<Class:E>#e=_0" [
        label = "block[id=0]()\l<U @e>$3: T.untyped = alias <C <U <undeclared-field-stub>>>\l<U <self>>: T.class_of(E) = cast(<U <self>>: NilClass, T.class_of(E));\l<U e>: T.untyped = load_arg(E.e=#e)\l<U @e>$3: T.untyped = <U e>\l<U <returnMethodTemp>>$2: T.untyped = <U @e>$3\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:E>#e=_0" -> "bb::<Class:E>#e=_1" [style="bold"];
    "bb::<Class:E>#e=_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:E>#e=_1" -> "bb::<Class:E>#e=_1" [style="bold"];
}

subgraph "cluster_::<Class:E>#e" {
    label = "::<Class:E>#e";
    color = blue;
    "bb::<Class:E>#e_0" [shape = invhouse];
    "bb::<Class:E>#e_1" [shape = parallelogram];

    "bb::<Class:E>#e_0" [
        label = "block[id=0]()\l<U @e>$3: T.untyped = alias <C <U <undeclared-field-stub>>>\l<U <self>>: T.class_of(E) = cast(<U <self>>: NilClass, T.class_of(E));\l<U <returnMethodTemp>>$2: T.untyped = <U @e>$3\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:E>#e_0" -> "bb::<Class:E>#e_1" [style="bold"];
    "bb::<Class:E>#e_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:E>#e_1" -> "bb::<Class:E>#e_1" [style="bold"];
}

subgraph "cluster_::<Class:Main>#main" {
    label = "::<Class:Main>#main";
    color = blue;
    "bb::<Class:Main>#main_0" [shape = invhouse];
    "bb::<Class:Main>#main_1" [shape = parallelogram];

    "bb::<Class:Main>#main_0" [
        label = "block[id=0]()\l<U @a>$116: T.untyped = alias <C <U <undeclared-field-stub>>>\l<U @@b>$120: T.untyped = alias <C <U <undeclared-field-stub>>>\l<U $c>$124: T.untyped = alias <U $c>\l<U <self>>: T.class_of(Main) = cast(<U <self>>: NilClass, T.class_of(Main));\l<U <statTemp>>$4: T.class_of(A) = alias <C <U A>>\l<U <block-pre-call-temp>>$5: T.untyped = <U <statTemp>>$4: T.class_of(A).<U each>()\l<U <selfRestore>>$6: T.class_of(Main) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_0" -> "bb::<Class:Main>#main_2" [style="bold"];
    "bb::<Class:Main>#main_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_1" -> "bb::<Class:Main>#main_1" [style="bold"];
    "bb::<Class:Main>#main_2" [
        label = "block[id=2](<U <self>>: T.class_of(Main), <U <selfRestore>>$6: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Main>#main_2" -> "bb::<Class:Main>#main_5" [style="bold"];
    "bb::<Class:Main>#main_2" -> "bb::<Class:Main>#main_3" [style="tapered"];

    "bb::<Class:Main>#main_3" [
        label = "block[id=3](<U <selfRestore>>$6: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\l<U <statTemp>>$3: T.untyped = Solve<::<Class:Main>#main#<block>>\l<U <self>>: T.class_of(Main) = <U <selfRestore>>$6\l<U <statTemp>>$24: T.class_of(A) = alias <C <U A>>\l<U <block-pre-call-temp>>$25: T.untyped = <U <statTemp>>$24: T.class_of(A).<U each>()\l<U <selfRestore>>$26: T.class_of(Main) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_3" -> "bb::<Class:Main>#main_6" [style="bold"];
    "bb::<Class:Main>#main_5" [
        label = "block[id=5](<U <self>>: T.class_of(Main), <U <selfRestore>>$6: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <self>>: T.class_of(Main) = loadSelf\l<U <blk>>$7: T.untyped = load_yield_params(::<Class:Main>#main#<block>, Main.main#<block>)\l<U <statTemp>>$12: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$14: Integer(1) = 1\l<U <statTemp>>$15: Integer(0) = 0\l<D <U <assignTemp>> $3>$1: T.untyped = <U <statTemp>>$12: T.class_of(<Magic>).<U <expand-splat>>(<U <blk>>$7: T.untyped, <U <statTemp>>$14: Integer(1), <U <statTemp>>$15: Integer(0))\l<U <statTemp>>$18: Integer(0) = 0\l<U a>$1: T.untyped = <D <U <assignTemp>> $3>$1: T.untyped.<U []>(<U <statTemp>>$18: Integer(0))\l<U <statTemp>>$20: T.untyped = <U a>$1: T.untyped.<U inspect>()\l<U <blockReturnTemp>>$9: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$20: T.untyped)\l<U <blockReturnTemp>>$22: T.noreturn = blockreturn<::<Class:Main>#main#<block>> <U <blockReturnTemp>>$9: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_5" -> "bb::<Class:Main>#main_2" [style="bold"];
    "bb::<Class:Main>#main_6" [
        label = "block[id=6](<U <self>>: T.class_of(Main), <U <selfRestore>>$26: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Main>#main_6" -> "bb::<Class:Main>#main_9" [style="bold"];
    "bb::<Class:Main>#main_6" -> "bb::<Class:Main>#main_7" [style="tapered"];

    "bb::<Class:Main>#main_7" [
        label = "block[id=7](<U <selfRestore>>$26: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\l<U <statTemp>>$23: T.untyped = Solve<::<Class:Main>#main#<block>>\l<U <self>>: T.class_of(Main) = <U <selfRestore>>$26\l<U <statTemp>>$45: T.class_of(A) = alias <C <U A>>\l<U <block-pre-call-temp>>$46: T.untyped = <U <statTemp>>$45: T.class_of(A).<U each>()\l<U <selfRestore>>$47: T.class_of(Main) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_7" -> "bb::<Class:Main>#main_10" [style="bold"];
    "bb::<Class:Main>#main_9" [
        label = "block[id=9](<U <self>>: T.class_of(Main), <U <selfRestore>>$26: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <self>>: T.class_of(Main) = loadSelf\l<U <blk>>$27: T.untyped = load_yield_params(::<Class:Main>#main#<block>, Main.main#<block>)\l<U forTemp>$2: T.untyped = <U <blk>>$27\l<U <statTemp>>$32: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$33: T.untyped = <U forTemp>$2: T.untyped.<U to_a>()\l<U <statTemp>>$35: Integer(1) = 1\l<U <statTemp>>$36: Integer(0) = 0\l<D <U <assignTemp>> $4>$2: T.untyped = <U <statTemp>>$32: T.class_of(<Magic>).<U <expand-splat>>(<U <statTemp>>$33: T.untyped, <U <statTemp>>$35: Integer(1), <U <statTemp>>$36: Integer(0))\l<U <statTemp>>$39: Integer(0) = 0\l<U a>$2: T.untyped = <D <U <assignTemp>> $4>$2: T.untyped.<U []>(<U <statTemp>>$39: Integer(0))\l<U <statTemp>>$41: T.untyped = <U a>$2: T.untyped.<U inspect>()\l<U <blockReturnTemp>>$29: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$41: T.untyped)\l<U <blockReturnTemp>>$43: T.noreturn = blockreturn<::<Class:Main>#main#<block>> <U <blockReturnTemp>>$29: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_9" -> "bb::<Class:Main>#main_6" [style="bold"];
    "bb::<Class:Main>#main_10" [
        label = "block[id=10](<U <self>>: T.class_of(Main), <U <selfRestore>>$47: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Main>#main_10" -> "bb::<Class:Main>#main_13" [style="bold"];
    "bb::<Class:Main>#main_10" -> "bb::<Class:Main>#main_11" [style="tapered"];

    "bb::<Class:Main>#main_11" [
        label = "block[id=11](<U <selfRestore>>$47: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\l<U <statTemp>>$44: T.untyped = Solve<::<Class:Main>#main#<block>>\l<U <self>>: T.class_of(Main) = <U <selfRestore>>$47\l<U <statTemp>>$72: T.class_of(A) = alias <C <U A>>\l<U <block-pre-call-temp>>$73: T.untyped = <U <statTemp>>$72: T.class_of(A).<U each>()\l<U <selfRestore>>$74: T.class_of(Main) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_11" -> "bb::<Class:Main>#main_14" [style="bold"];
    "bb::<Class:Main>#main_13" [
        label = "block[id=13](<U <self>>: T.class_of(Main), <U <selfRestore>>$47: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <self>>: T.class_of(Main) = loadSelf\l<U <blk>>$48: T.untyped = load_yield_params(::<Class:Main>#main#<block>, Main.main#<block>)\l<U <statTemp>>$53: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$55: Integer(2) = 2\l<U <statTemp>>$56: Integer(0) = 0\l<D <U <assignTemp>> $6>$3: T.untyped = <U <statTemp>>$53: T.class_of(<Magic>).<U <expand-splat>>(<U <blk>>$48: T.untyped, <U <statTemp>>$55: Integer(2), <U <statTemp>>$56: Integer(0))\l<U <statTemp>>$59: Integer(0) = 0\l<U a>$3: T.untyped = <D <U <assignTemp>> $6>$3: T.untyped.<U []>(<U <statTemp>>$59: Integer(0))\l<U <statTemp>>$62: Integer(1) = 1\l<U b>$3: T.untyped = <D <U <assignTemp>> $6>$3: T.untyped.<U []>(<U <statTemp>>$62: Integer(1))\l<U <statTemp>>$65: T.untyped = <U a>$3: T.untyped.<U inspect>()\l<U <statTemp>>$63: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$65: T.untyped)\l<U <statTemp>>$68: T.untyped = <U b>$3: T.untyped.<U inspect>()\l<U <blockReturnTemp>>$50: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$68: T.untyped)\l<U <blockReturnTemp>>$70: T.noreturn = blockreturn<::<Class:Main>#main#<block>> <U <blockReturnTemp>>$50: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_13" -> "bb::<Class:Main>#main_10" [style="bold"];
    "bb::<Class:Main>#main_14" [
        label = "block[id=14](<U <self>>: T.class_of(Main), <U <selfRestore>>$74: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Main>#main_14" -> "bb::<Class:Main>#main_17" [style="bold"];
    "bb::<Class:Main>#main_14" -> "bb::<Class:Main>#main_15" [style="tapered"];

    "bb::<Class:Main>#main_15" [
        label = "block[id=15](<U <selfRestore>>$74: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\l<U <statTemp>>$71: T.untyped = Solve<::<Class:Main>#main#<block>>\l<U <self>>: T.class_of(Main) = <U <selfRestore>>$74\l<U <statTemp>>$101: String(\"main\") = \"main\"\l<U <statTemp>>$99: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$101: String(\"main\"))\l<U <statTemp>>$103: T.class_of(A) = alias <C <U A>>\l<U <block-pre-call-temp>>$104: T.untyped = <U <statTemp>>$103: T.class_of(A).<U each>()\l<U <selfRestore>>$105: T.class_of(Main) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_15" -> "bb::<Class:Main>#main_18" [style="bold"];
    "bb::<Class:Main>#main_17" [
        label = "block[id=17](<U <self>>: T.class_of(Main), <U <selfRestore>>$74: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <self>>: T.class_of(Main) = loadSelf\l<U <blk>>$75: T.untyped = load_yield_params(::<Class:Main>#main#<block>, Main.main#<block>)\l<U forTemp>$4: T.untyped = <U <blk>>$75\l<U <statTemp>>$80: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$81: T.untyped = <U forTemp>$4: T.untyped.<U to_a>()\l<U <statTemp>>$83: Integer(2) = 2\l<U <statTemp>>$84: Integer(0) = 0\l<D <U <assignTemp>> $7>$4: T.untyped = <U <statTemp>>$80: T.class_of(<Magic>).<U <expand-splat>>(<U <statTemp>>$81: T.untyped, <U <statTemp>>$83: Integer(2), <U <statTemp>>$84: Integer(0))\l<U <statTemp>>$87: Integer(0) = 0\l<U a>$4: T.untyped = <D <U <assignTemp>> $7>$4: T.untyped.<U []>(<U <statTemp>>$87: Integer(0))\l<U <statTemp>>$90: Integer(1) = 1\l<U b>$4: T.untyped = <D <U <assignTemp>> $7>$4: T.untyped.<U []>(<U <statTemp>>$90: Integer(1))\l<U <statTemp>>$93: T.untyped = <U a>$4: T.untyped.<U inspect>()\l<U <statTemp>>$91: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$93: T.untyped)\l<U <statTemp>>$96: T.untyped = <U b>$4: T.untyped.<U inspect>()\l<U <blockReturnTemp>>$77: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$96: T.untyped)\l<U <blockReturnTemp>>$98: T.noreturn = blockreturn<::<Class:Main>#main#<block>> <U <blockReturnTemp>>$77: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_17" -> "bb::<Class:Main>#main_14" [style="bold"];
    "bb::<Class:Main>#main_18" [
        label = "block[id=18](<U <self>>: T.class_of(Main), <U <selfRestore>>$105: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Main>#main_18" -> "bb::<Class:Main>#main_21" [style="bold"];
    "bb::<Class:Main>#main_18" -> "bb::<Class:Main>#main_19" [style="tapered"];

    "bb::<Class:Main>#main_19" [
        label = "block[id=19](<U <selfRestore>>$105: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\l<U <statTemp>>$102: T.untyped = Solve<::<Class:Main>#main#<block>>\l<U <self>>: T.class_of(Main) = <U <selfRestore>>$105\l<U <statTemp>>$156: T.class_of(A) = alias <C <U A>>\l<U <block-pre-call-temp>>$157: T.untyped = <U <statTemp>>$156: T.class_of(A).<U each>()\l<U <selfRestore>>$158: T.class_of(Main) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_19" -> "bb::<Class:Main>#main_22" [style="bold"];
    "bb::<Class:Main>#main_21" [
        label = "block[id=21](<U <self>>: T.class_of(Main), <U <selfRestore>>$105: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <self>>: T.class_of(Main) = loadSelf\l<U <blk>>$106: T.untyped = load_yield_params(::<Class:Main>#main#<block>, Main.main#<block>)\l<U <statTemp>>$111: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$113: Integer(5) = 5\l<U <statTemp>>$114: Integer(0) = 0\l<D <U <assignTemp>> $9>$5: T.untyped = <U <statTemp>>$111: T.class_of(<Magic>).<U <expand-splat>>(<U <blk>>$106: T.untyped, <U <statTemp>>$113: Integer(5), <U <statTemp>>$114: Integer(0))\l<U <statTemp>>$118: Integer(0) = 0\l<U @a>$116: T.untyped = <D <U <assignTemp>> $9>$5: T.untyped.<U []>(<U <statTemp>>$118: Integer(0))\l<U <statTemp>>$122: Integer(1) = 1\l<U @@b>$120: T.untyped = <D <U <assignTemp>> $9>$5: T.untyped.<U []>(<U <statTemp>>$122: Integer(1))\l<U <statTemp>>$126: Integer(2) = 2\l<U $c>$124: T.untyped = <D <U <assignTemp>> $9>$5: T.untyped.<U []>(<U <statTemp>>$126: Integer(2))\l<U <statTemp>>$129: Integer(3) = 3\l<U d>$5: T.untyped = <D <U <assignTemp>> $9>$5: T.untyped.<U []>(<U <statTemp>>$129: Integer(3))\l<U <statTemp>>$131: T.class_of(E) = alias <C <U E>>\l<U <statTemp>>$134: Integer(4) = 4\l<U <statTemp>>$132: T.untyped = <D <U <assignTemp>> $9>$5: T.untyped.<U []>(<U <statTemp>>$134: Integer(4))\l<U <statTemp>>$130: T.untyped = <U <statTemp>>$131: T.class_of(E).<U e=>(<U <statTemp>>$132: T.untyped)\l<U <statTemp>>$137: T.untyped = <U @a>$116: T.untyped.<U inspect>()\l<U <statTemp>>$135: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$137: T.untyped)\l<U <statTemp>>$141: T.untyped = <U @@b>$120: T.untyped.<U inspect>()\l<U <statTemp>>$139: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$141: T.untyped)\l<U <statTemp>>$145: T.untyped = <U $c>$124: T.untyped.<U inspect>()\l<U <statTemp>>$143: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$145: T.untyped)\l<U <statTemp>>$149: T.untyped = <U d>$5: T.untyped.<U inspect>()\l<U <statTemp>>$147: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$149: T.untyped)\l<U <statTemp>>$154: T.class_of(E) = alias <C <U E>>\l<U <statTemp>>$153: T.untyped = <U <statTemp>>$154: T.class_of(E).<U e>()\l<U <statTemp>>$152: T.untyped = <U <statTemp>>$153: T.untyped.<U inspect>()\l<U <blockReturnTemp>>$108: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$152: T.untyped)\l<U <blockReturnTemp>>$155: T.noreturn = blockreturn<::<Class:Main>#main#<block>> <U <blockReturnTemp>>$108: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_21" -> "bb::<Class:Main>#main_18" [style="bold"];
    "bb::<Class:Main>#main_22" [
        label = "block[id=22](<U <self>>: T.class_of(Main), <U <selfRestore>>$158: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Main>#main_22" -> "bb::<Class:Main>#main_25" [style="bold"];
    "bb::<Class:Main>#main_22" -> "bb::<Class:Main>#main_23" [style="tapered"];

    "bb::<Class:Main>#main_23" [
        label = "block[id=23](<U <selfRestore>>$158: T.class_of(Main))\l<U <returnMethodTemp>>$2: T.untyped = Solve<::<Class:Main>#main#<block>>\l<U <self>>: T.class_of(Main) = <U <selfRestore>>$158\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: T.untyped\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_23" -> "bb::<Class:Main>#main_1" [style="bold"];
    "bb::<Class:Main>#main_25" [
        label = "block[id=25](<U <self>>: T.class_of(Main), <U <selfRestore>>$158: T.class_of(Main), <U @a>$116: T.untyped, <U @@b>$120: T.untyped, <U $c>$124: T.untyped)\louterLoops: 1\l<U <self>>: T.class_of(Main) = loadSelf\l<U <blk>>$159: T.untyped = load_yield_params(::<Class:Main>#main#<block>, Main.main#<block>)\l<U forTemp>$6: T.untyped = <U <blk>>$159\l<U <statTemp>>$164: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$165: T.untyped = <U forTemp>$6: T.untyped.<U to_a>()\l<U <statTemp>>$167: Integer(5) = 5\l<U <statTemp>>$168: Integer(0) = 0\l<D <U <assignTemp>> $10>$6: T.untyped = <U <statTemp>>$164: T.class_of(<Magic>).<U <expand-splat>>(<U <statTemp>>$165: T.untyped, <U <statTemp>>$167: Integer(5), <U <statTemp>>$168: Integer(0))\l<U <statTemp>>$171: Integer(0) = 0\l<U @a>$116: T.untyped = <D <U <assignTemp>> $10>$6: T.untyped.<U []>(<U <statTemp>>$171: Integer(0))\l<U <statTemp>>$174: Integer(1) = 1\l<U @@b>$120: T.untyped = <D <U <assignTemp>> $10>$6: T.untyped.<U []>(<U <statTemp>>$174: Integer(1))\l<U <statTemp>>$177: Integer(2) = 2\l<U $c>$124: T.untyped = <D <U <assignTemp>> $10>$6: T.untyped.<U []>(<U <statTemp>>$177: Integer(2))\l<U <statTemp>>$180: Integer(3) = 3\l<U d>$6: T.untyped = <D <U <assignTemp>> $10>$6: T.untyped.<U []>(<U <statTemp>>$180: Integer(3))\l<U <statTemp>>$182: T.class_of(E) = alias <C <U E>>\l<U <statTemp>>$185: Integer(4) = 4\l<U <statTemp>>$183: T.untyped = <D <U <assignTemp>> $10>$6: T.untyped.<U []>(<U <statTemp>>$185: Integer(4))\l<U <statTemp>>$181: T.untyped = <U <statTemp>>$182: T.class_of(E).<U e=>(<U <statTemp>>$183: T.untyped)\l<U <statTemp>>$188: T.untyped = <U @a>$116: T.untyped.<U inspect>()\l<U <statTemp>>$186: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$188: T.untyped)\l<U <statTemp>>$192: T.untyped = <U @@b>$120: T.untyped.<U inspect>()\l<U <statTemp>>$190: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$192: T.untyped)\l<U <statTemp>>$196: T.untyped = <U $c>$124: T.untyped.<U inspect>()\l<U <statTemp>>$194: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$196: T.untyped)\l<U <statTemp>>$200: T.untyped = <U d>$6: T.untyped.<U inspect>()\l<U <statTemp>>$198: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$200: T.untyped)\l<U <statTemp>>$205: T.class_of(E) = alias <C <U E>>\l<U <statTemp>>$204: T.untyped = <U <statTemp>>$205: T.class_of(E).<U e>()\l<U <statTemp>>$203: T.untyped = <U <statTemp>>$204: T.untyped.<U inspect>()\l<U <blockReturnTemp>>$161: NilClass = <U <self>>: T.class_of(Main).<U puts>(<U <statTemp>>$203: T.untyped)\l<U <blockReturnTemp>>$206: T.noreturn = blockreturn<::<Class:Main>#main#<block>> <U <blockReturnTemp>>$161: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:Main>#main_25" -> "bb::<Class:Main>#main_22" [style="bold"];
}

}

