digraph "self_type.rb" {
subgraph "cluster_::Object#rnd" {
    label = "::Object#rnd";
    color = blue;
    "bb::Object#rnd_0" [shape = invhouse];
    "bb::Object#rnd_1" [shape = parallelogram];

    "bb::Object#rnd_0" [
        label = "block[id=0]()\l<U <self>>: Object = cast(<U <self>>: NilClass, Object);\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: NilClass\l<unconditional>\l"
    ];

    "bb::Object#rnd_0" -> "bb::Object#rnd_1" [style="bold"];
    "bb::Object#rnd_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Object#rnd_1" -> "bb::Object#rnd_1" [style="bold"];
}

subgraph "cluster_::<Class:<root>>#<static-init>" {
    label = "::<Class:<root>>#<static-init>";
    color = blue;
    "bb::<Class:<root>>#<static-init>_0" [shape = invhouse];
    "bb::<Class:<root>>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:<root>>#<static-init>_0" [
        label = "block[id=0]()\l<U <self>>: T.class_of(<root>) = cast(<U <self>>: NilClass, T.class_of(<root>));\l<U <statTemp>>$5: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$6: T.class_of(Parent) = alias <C <U Parent>>\l<U <statTemp>>$4: Sorbet::Private::Static::Void = <U <statTemp>>$5: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$6: T.class_of(Parent))\l<U <statTemp>>$9: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$10: T.class_of(Normal) = alias <C <U Normal>>\l<U <statTemp>>$8: Sorbet::Private::Static::Void = <U <statTemp>>$9: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$10: T.class_of(Normal))\l<U <statTemp>>$12: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$13: T.class_of(Parent) = alias <C <U Parent>>\l<U <statTemp>>$11: Sorbet::Private::Static::Void = <U <statTemp>>$12: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$13: T.class_of(Parent))\l<U <statTemp>>$16: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$17: T.class_of(Generic) = alias <C <U Generic>>\l<U <statTemp>>$15: Sorbet::Private::Static::Void = <U <statTemp>>$16: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$17: T.class_of(Generic))\l<U <statTemp>>$19: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$20: T.class_of(Parent) = alias <C <U Parent>>\l<U <statTemp>>$18: Sorbet::Private::Static::Void = <U <statTemp>>$19: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$20: T.class_of(Parent))\l<U <statTemp>>$23: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$24: T.class_of(Normal) = alias <C <U Normal>>\l<U <statTemp>>$22: Sorbet::Private::Static::Void = <U <statTemp>>$23: T.class_of(Sorbet::Private::Static).<U keep_for_typechecking>(<U <statTemp>>$24: T.class_of(Normal))\l<U <statTemp>>$27: T.class_of(Normal) = alias <C <U Normal>>\l<U <statTemp>>$26: Normal = <U <statTemp>>$27: T.class_of(Normal).<U new>()\l<U <castTemp>>$25: Normal = <U <statTemp>>$26: Normal.<U returns_self>()\l<U <statTemp>>$21: Normal = cast(<U <castTemp>>$25: Normal, Normal);\l<U <statTemp>>$30: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$32: T.class_of(Generic) = alias <C <U Generic>>\l<U <statTemp>>$33: T.class_of(String) = alias <C <U String>>\l<U <statTemp>>$31: <Type: Generic[String]> = <U <statTemp>>$32: T.class_of(Generic).<U []>(<U <statTemp>>$33: T.class_of(String))\l<U <statTemp>>$29: Sorbet::Private::Static::Void = <U <statTemp>>$30: T.class_of(Sorbet::Private::Static).<U keep_for_typechecking>(<U <statTemp>>$31: <Type: Generic[String]>)\l<U <statTemp>>$37: T.class_of(Generic) = alias <C <U Generic>>\l<U <statTemp>>$38: T.class_of(String) = alias <C <U String>>\l<U <statTemp>>$36: <Type: Generic[String]> = <U <statTemp>>$37: T.class_of(Generic).<U []>(<U <statTemp>>$38: T.class_of(String))\l<U <statTemp>>$35: Generic[String] = <U <statTemp>>$36: <Type: Generic[String]>.<U new>()\l<U <castTemp>>$34: Generic[String] = <U <statTemp>>$35: Generic[String].<U returns_self>()\l<U <statTemp>>$28: Generic[String] = cast(<U <castTemp>>$34: Generic[String], AppliedType {\l  klass = <C <U Generic>>\l  targs = [\l    <C <U TM>> = String\l  ]\l});\l<U <statTemp>>$41: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$42: T.class_of(B) = alias <C <U B>>\l<U <statTemp>>$40: Sorbet::Private::Static::Void = <U <statTemp>>$41: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$42: T.class_of(B))\l<U <statTemp>>$45: T.class_of(Generic) = alias <C <U Generic>>\l<U <statTemp>>$46: T.class_of(String) = alias <C <U String>>\l<U <statTemp>>$44: <Type: Generic[String]> = <U <statTemp>>$45: T.class_of(Generic).<U []>(<U <statTemp>>$46: T.class_of(String))\l<U a>: Generic[String] = <U <statTemp>>$44: <Type: Generic[String]>.<U new>()\l<U <statTemp>>$50: T.class_of(B) = alias <C <U B>>\l<U <ifTemp>>$48: T.any(TrueClass, FalseClass) = <U a>: Generic[String].<U is_a?>(<U <statTemp>>$50: T.class_of(B))\l<U <ifTemp>>$48: T.any(TrueClass, FalseClass)\l"
    ];

    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_2" [style="bold"];
    "bb::<Class:<root>>#<static-init>_0" -> "bb::<Class:<root>>#<static-init>_4" [style="tapered"];

    "bb::<Class:<root>>#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_1" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_2" [
        label = "block[id=2](<U <self>>: T.class_of(<root>), <U a>: T.all(Generic[String], B))\l<U <statTemp>>$52: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$54: T.class_of(T) = alias <C <U T>>\l<U <statTemp>>$56: T.class_of(Generic) = alias <C <U Generic>>\l<U <statTemp>>$57: T.class_of(String) = alias <C <U String>>\l<U <statTemp>>$55: <Type: Generic[String]> = <U <statTemp>>$56: T.class_of(Generic).<U []>(<U <statTemp>>$57: T.class_of(String))\l<U <statTemp>>$58: T.class_of(B) = alias <C <U B>>\l<U <statTemp>>$53: <Type: T.all(Generic[String], B)> = <U <statTemp>>$54: T.class_of(T).<U all>(<U <statTemp>>$55: <Type: Generic[String]>, <U <statTemp>>$58: T.class_of(B))\l<U <statTemp>>$51: Sorbet::Private::Static::Void = <U <statTemp>>$52: T.class_of(Sorbet::Private::Static).<U keep_for_typechecking>(<U <statTemp>>$53: <Type: T.all(Generic[String], B)>)\l<U <castTemp>>$59: T.all(Generic[String], B) = <U a>: T.all(Generic[String], B).<U returns_self>()\l<U <statTemp>>$47: T.all(Generic[String], B) = cast(<U <castTemp>>$59: T.all(Generic[String], B), AppliedType {\l      klass = <C <U Generic>>\l      targs = [\l        <C <U TM>> = String\l      ]\l    } & B);\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_2" -> "bb::<Class:<root>>#<static-init>_4" [style="bold"];
    "bb::<Class:<root>>#<static-init>_4" [
        label = "block[id=4](<U <self>>: T.class_of(<root>))\l<U <statTemp>>$63: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$64: T.class_of(Array) = alias <C <U Array>>\l<U <statTemp>>$62: Sorbet::Private::Static::Void = <U <statTemp>>$63: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$64: T.class_of(Array))\l<U <statTemp>>$67: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <arrayTemp>>$69: T.class_of(Integer) = alias <C <U Integer>>\l<U <arrayTemp>>$70: T.class_of(Integer) = alias <C <U Integer>>\l<U <magic>>$71: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$68: [T.class_of(Integer), T.class_of(Integer)] = <U <magic>>$71: T.class_of(<Magic>).<U <build-array>>(<U <arrayTemp>>$69: T.class_of(Integer), <U <arrayTemp>>$70: T.class_of(Integer))\l<U <statTemp>>$66: Sorbet::Private::Static::Void = <U <statTemp>>$67: T.class_of(Sorbet::Private::Static).<U keep_for_typechecking>(<U <statTemp>>$68: [T.class_of(Integer), T.class_of(Integer)])\l<U <arrayTemp>>$74: Integer(1) = 1\l<U <arrayTemp>>$75: Integer(2) = 2\l<U <magic>>$76: T.class_of(<Magic>) = alias <C <U <Magic>>>\l<U <statTemp>>$73: [Integer(1), Integer(2)] = <U <magic>>$76: T.class_of(<Magic>).<U <build-array>>(<U <arrayTemp>>$74: Integer(1), <U <arrayTemp>>$75: Integer(2))\l<U <castTemp>>$72: [Integer(1), Integer(2)] = <U <statTemp>>$73: [Integer(1), Integer(2)].<U returns_self>()\l<U <statTemp>>$65: [Integer, Integer] = cast(<U <castTemp>>$72: [Integer(1), Integer(2)], TupleType {\l  0 = Integer\l  1 = Integer\l});\l<U <statTemp>>$79: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$80: T.class_of(A) = alias <C <U A>>\l<U <statTemp>>$78: Sorbet::Private::Static::Void = <U <statTemp>>$79: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$80: T.class_of(A))\l<U <statTemp>>$83: T.class_of(Sorbet::Private::Static) = alias <C <U Static>>\l<U <statTemp>>$84: T.class_of(B) = alias <C <U B>>\l<U <statTemp>>$82: Sorbet::Private::Static::Void = <U <statTemp>>$83: T.class_of(Sorbet::Private::Static).<U keep_for_ide>(<U <statTemp>>$84: T.class_of(B))\l<U <statTemp>>$86: T.class_of(A) = alias <C <U A>>\l<U s>: A = <U <statTemp>>$86: T.class_of(A).<U new>()\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_4" -> "bb::<Class:<root>>#<static-init>_5" [style="bold"];
    "bb::<Class:<root>>#<static-init>_5" [
        label = "block[id=5](<U <self>>: T.class_of(<root>), <U s>: A)\louterLoops: 1\l<U <whileTemp>>$88: T.untyped = <U <self>>: T.class_of(<root>).<U rnd>()\l<U <whileTemp>>$88: T.untyped\l"
    ];

    "bb::<Class:<root>>#<static-init>_5" -> "bb::<Class:<root>>#<static-init>_8" [style="bold"];
    "bb::<Class:<root>>#<static-init>_5" -> "bb::<Class:<root>>#<static-init>_7" [style="tapered"];

    "bb::<Class:<root>>#<static-init>_7" [
        label = "block[id=7](<U <self>>: T.class_of(<root>), <U s>: A)\l<U <statTemp>>$95: NilClass = <U <self>>: T.class_of(<root>).<U puts>(<U s>: A)\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: NilClass\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_7" -> "bb::<Class:<root>>#<static-init>_1" [style="bold"];
    "bb::<Class:<root>>#<static-init>_8" [
        label = "block[id=8](<U <self>>: T.class_of(<root>), <U s>: A)\louterLoops: 1\l<U <statTemp>>$93: T.class_of(B) = alias <C <U B>>\l<U <ifTemp>>$91: T.any(TrueClass, FalseClass) = <U s>: A.<U is_a?>(<U <statTemp>>$93: T.class_of(B))\l<U <ifTemp>>$91: T.any(TrueClass, FalseClass)\l"
    ];

    "bb::<Class:<root>>#<static-init>_8" -> "bb::<Class:<root>>#<static-init>_9" [style="bold"];
    "bb::<Class:<root>>#<static-init>_8" -> "bb::<Class:<root>>#<static-init>_5" [style="tapered"];

    "bb::<Class:<root>>#<static-init>_9" [
        label = "block[id=9](<U <self>>: T.class_of(<root>), <U s>: T.all(A, B))\louterLoops: 1\l<U <statTemp>>$94: T.all(A, B) = <U s>\l<U s>: T.all(A, B) = <U <statTemp>>$94: T.all(A, B).<U returns_self>()\l<unconditional>\l"
    ];

    "bb::<Class:<root>>#<static-init>_9" -> "bb::<Class:<root>>#<static-init>_5" [style="bold"];
}

subgraph "cluster_::Parent#returns_self" {
    label = "::Parent#returns_self";
    color = blue;
    "bb::Parent#returns_self_0" [shape = invhouse];
    "bb::Parent#returns_self_1" [shape = parallelogram];

    "bb::Parent#returns_self_0" [
        label = "block[id=0]()\l<U <self>>: Parent = cast(<U <self>>: NilClass, Parent);\l<U <returnMethodTemp>>$2: Parent = <U <self>>\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: Parent\l<unconditional>\l"
    ];

    "bb::Parent#returns_self_0" -> "bb::Parent#returns_self_1" [style="bold"];
    "bb::Parent#returns_self_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Parent#returns_self_1" -> "bb::Parent#returns_self_1" [style="bold"];
}

subgraph "cluster_::<Class:Parent>#<static-init>" {
    label = "::<Class:Parent>#<static-init>";
    color = blue;
    "bb::<Class:Parent>#<static-init>_0" [shape = invhouse];
    "bb::<Class:Parent>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:Parent>#<static-init>_0" [
        label = "block[id=0]()\l<U <self>>: T.class_of(Parent) = cast(<U <self>>: NilClass, T.class_of(Parent));\l<U <block-pre-call-temp>>$4: Sorbet::Private::Static::Void = <U <self>>: T.class_of(Parent).<U sig>()\l<U <selfRestore>>$5: T.class_of(Parent) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Parent>#<static-init>_0" -> "bb::<Class:Parent>#<static-init>_2" [style="bold"];
    "bb::<Class:Parent>#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:Parent>#<static-init>_1" -> "bb::<Class:Parent>#<static-init>_1" [style="bold"];
    "bb::<Class:Parent>#<static-init>_2" [
        label = "block[id=2](<U <self>>: T.class_of(Parent), <U <selfRestore>>$5: T.class_of(Parent))\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Parent>#<static-init>_2" -> "bb::<Class:Parent>#<static-init>_5" [style="bold"];
    "bb::<Class:Parent>#<static-init>_2" -> "bb::<Class:Parent>#<static-init>_3" [style="tapered"];

    "bb::<Class:Parent>#<static-init>_3" [
        label = "block[id=3](<U <selfRestore>>$5: T.class_of(Parent))\l<U <returnMethodTemp>>$2: Sorbet::Private::Static::Void = Solve<::<Class:Parent>#<static-init>#<block>>\l<U <self>>: T.class_of(Parent) = <U <selfRestore>>$5\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: Sorbet::Private::Static::Void\l<unconditional>\l"
    ];

    "bb::<Class:Parent>#<static-init>_3" -> "bb::<Class:Parent>#<static-init>_1" [style="bold"];
    "bb::<Class:Parent>#<static-init>_5" [
        label = "block[id=5](<U <self>>: T.class_of(Parent), <U <selfRestore>>$5: T.class_of(Parent))\louterLoops: 1\l<U <self>>: T::Private::Methods::SigBuilder = loadSelf\l<U <statTemp>>$11: T.class_of(T) = alias <C <U T>>\l<U <statTemp>>$10: T.untyped = <U <statTemp>>$11: T.class_of(T).<U self_type>()\l<U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder = <U <self>>: T::Private::Methods::SigBuilder.<U returns>(<U <statTemp>>$10: T.untyped)\l<U <blockReturnTemp>>$12: T.noreturn = blockreturn<::<Class:Parent>#<static-init>#<block>> <U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder\l<unconditional>\l"
    ];

    "bb::<Class:Parent>#<static-init>_5" -> "bb::<Class:Parent>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::Generic#bad" {
    label = "::Generic#bad";
    color = blue;
    "bb::Generic#bad_0" [shape = invhouse];
    "bb::Generic#bad_1" [shape = parallelogram];

    "bb::Generic#bad_0" [
        label = "block[id=0]()\l<U <self>>: Generic[Generic::TM] = cast(<U <self>>: NilClass, AppliedType {\l  klass = <C <U Generic>>\l  targs = [\l    <C <U TM>> = SelfTypeParam(<C <U Generic>><C <U TM>>)\l  ]\l});\l<U <statTemp>>$4: T.class_of(Generic) = alias <C <U Generic>>\l<U <statTemp>>$6: T.class_of(T) = alias <C <U T>>\l<U <statTemp>>$5: T.untyped = <U <statTemp>>$6: T.class_of(T).<U untyped>()\l<U <statTemp>>$3: <Type: Generic[T.untyped]> = <U <statTemp>>$4: T.class_of(Generic).<U []>(<U <statTemp>>$5: T.untyped)\l<U <returnMethodTemp>>$2: Generic[T.untyped] = <U <statTemp>>$3: <Type: Generic[T.untyped]>.<U new>()\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: Generic[T.untyped]\l<unconditional>\l"
    ];

    "bb::Generic#bad_0" -> "bb::Generic#bad_1" [style="bold"];
    "bb::Generic#bad_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Generic#bad_1" -> "bb::Generic#bad_1" [style="bold"];
}

subgraph "cluster_::<Class:Generic>#<static-init>" {
    label = "::<Class:Generic>#<static-init>";
    color = blue;
    "bb::<Class:Generic>#<static-init>_0" [shape = invhouse];
    "bb::<Class:Generic>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:Generic>#<static-init>_0" [
        label = "block[id=0]()\l<U <self>>: T.class_of(Generic) = cast(<U <self>>: NilClass, T.class_of(Generic));\l<U <block-pre-call-temp>>$4: Sorbet::Private::Static::Void = <U <self>>: T.class_of(Generic).<U sig>()\l<U <selfRestore>>$5: T.class_of(Generic) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Generic>#<static-init>_0" -> "bb::<Class:Generic>#<static-init>_2" [style="bold"];
    "bb::<Class:Generic>#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:Generic>#<static-init>_1" -> "bb::<Class:Generic>#<static-init>_1" [style="bold"];
    "bb::<Class:Generic>#<static-init>_2" [
        label = "block[id=2](<U <self>>: T.class_of(Generic), <U <selfRestore>>$5: T.class_of(Generic))\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Generic>#<static-init>_2" -> "bb::<Class:Generic>#<static-init>_5" [style="bold"];
    "bb::<Class:Generic>#<static-init>_2" -> "bb::<Class:Generic>#<static-init>_3" [style="tapered"];

    "bb::<Class:Generic>#<static-init>_3" [
        label = "block[id=3](<U <selfRestore>>$5: T.class_of(Generic))\l<U <returnMethodTemp>>$2: Sorbet::Private::Static::Void = Solve<::<Class:Generic>#<static-init>#<block>>\l<U <self>>: T.class_of(Generic) = <U <selfRestore>>$5\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: Sorbet::Private::Static::Void\l<unconditional>\l"
    ];

    "bb::<Class:Generic>#<static-init>_3" -> "bb::<Class:Generic>#<static-init>_1" [style="bold"];
    "bb::<Class:Generic>#<static-init>_5" [
        label = "block[id=5](<U <self>>: T.class_of(Generic), <U <selfRestore>>$5: T.class_of(Generic))\louterLoops: 1\l<U <self>>: T::Private::Methods::SigBuilder = loadSelf\l<U <statTemp>>$11: T.class_of(Generic) = alias <C <U Generic>>\l<U <statTemp>>$13: T.class_of(T) = alias <C <U T>>\l<U <statTemp>>$12: T.untyped = <U <statTemp>>$13: T.class_of(T).<U self_type>()\l<U <statTemp>>$10: <Type: Generic[T.untyped]> = <U <statTemp>>$11: T.class_of(Generic).<U []>(<U <statTemp>>$12: T.untyped)\l<U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder = <U <self>>: T::Private::Methods::SigBuilder.<U returns>(<U <statTemp>>$10: <Type: Generic[T.untyped]>)\l<U <blockReturnTemp>>$14: T.noreturn = blockreturn<::<Class:Generic>#<static-init>#<block>> <U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder\l<unconditional>\l"
    ];

    "bb::<Class:Generic>#<static-init>_5" -> "bb::<Class:Generic>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::Array#returns_self" {
    label = "::Array#returns_self";
    color = blue;
    "bb::Array#returns_self_0" [shape = invhouse];
    "bb::Array#returns_self_1" [shape = parallelogram];

    "bb::Array#returns_self_0" [
        label = "block[id=0]()\l<U <self>>: T::Array[Array::Elem] = cast(<U <self>>: NilClass, AppliedType {\l  klass = <C <U Array>>\l  targs = [\l    <C <U Elem>> = SelfTypeParam(<C <U Array>><C <U Elem>>)\l  ]\l});\l<U <returnMethodTemp>>$2: T::Array[Array::Elem] = <U <self>>\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: T::Array[Array::Elem]\l<unconditional>\l"
    ];

    "bb::Array#returns_self_0" -> "bb::Array#returns_self_1" [style="bold"];
    "bb::Array#returns_self_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::Array#returns_self_1" -> "bb::Array#returns_self_1" [style="bold"];
}

subgraph "cluster_::<Class:Array>#<static-init>" {
    label = "::<Class:Array>#<static-init>";
    color = blue;
    "bb::<Class:Array>#<static-init>_0" [shape = invhouse];
    "bb::<Class:Array>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:Array>#<static-init>_0" [
        label = "block[id=0]()\l<U <self>>: T.class_of(Array) = cast(<U <self>>: NilClass, T.class_of(Array));\l<U <block-pre-call-temp>>$4: Sorbet::Private::Static::Void = <U <self>>: T.class_of(Array).<U sig>()\l<U <selfRestore>>$5: T.class_of(Array) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:Array>#<static-init>_0" -> "bb::<Class:Array>#<static-init>_2" [style="bold"];
    "bb::<Class:Array>#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:Array>#<static-init>_1" -> "bb::<Class:Array>#<static-init>_1" [style="bold"];
    "bb::<Class:Array>#<static-init>_2" [
        label = "block[id=2](<U <self>>: T.class_of(Array), <U <selfRestore>>$5: T.class_of(Array))\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:Array>#<static-init>_2" -> "bb::<Class:Array>#<static-init>_5" [style="bold"];
    "bb::<Class:Array>#<static-init>_2" -> "bb::<Class:Array>#<static-init>_3" [style="tapered"];

    "bb::<Class:Array>#<static-init>_3" [
        label = "block[id=3](<U <selfRestore>>$5: T.class_of(Array))\l<U <returnMethodTemp>>$2: Sorbet::Private::Static::Void = Solve<::<Class:Array>#<static-init>#<block>>\l<U <self>>: T.class_of(Array) = <U <selfRestore>>$5\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: Sorbet::Private::Static::Void\l<unconditional>\l"
    ];

    "bb::<Class:Array>#<static-init>_3" -> "bb::<Class:Array>#<static-init>_1" [style="bold"];
    "bb::<Class:Array>#<static-init>_5" [
        label = "block[id=5](<U <self>>: T.class_of(Array), <U <selfRestore>>$5: T.class_of(Array))\louterLoops: 1\l<U <self>>: T::Private::Methods::SigBuilder = loadSelf\l<U <statTemp>>$11: T.class_of(T) = alias <C <U T>>\l<U <statTemp>>$10: T.untyped = <U <statTemp>>$11: T.class_of(T).<U self_type>()\l<U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder = <U <self>>: T::Private::Methods::SigBuilder.<U returns>(<U <statTemp>>$10: T.untyped)\l<U <blockReturnTemp>>$12: T.noreturn = blockreturn<::<Class:Array>#<static-init>#<block>> <U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder\l<unconditional>\l"
    ];

    "bb::<Class:Array>#<static-init>_5" -> "bb::<Class:Array>#<static-init>_2" [style="bold"];
}

subgraph "cluster_::B#returns_self" {
    label = "::B#returns_self";
    color = blue;
    "bb::B#returns_self_0" [shape = invhouse];
    "bb::B#returns_self_1" [shape = parallelogram];

    "bb::B#returns_self_0" [
        label = "block[id=0]()\l<U <self>>: B = cast(<U <self>>: NilClass, B);\l<U <returnMethodTemp>>$2: B = <U <self>>\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: B\l<unconditional>\l"
    ];

    "bb::B#returns_self_0" -> "bb::B#returns_self_1" [style="bold"];
    "bb::B#returns_self_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::B#returns_self_1" -> "bb::B#returns_self_1" [style="bold"];
}

subgraph "cluster_::<Class:B>#<static-init>" {
    label = "::<Class:B>#<static-init>";
    color = blue;
    "bb::<Class:B>#<static-init>_0" [shape = invhouse];
    "bb::<Class:B>#<static-init>_1" [shape = parallelogram];

    "bb::<Class:B>#<static-init>_0" [
        label = "block[id=0]()\l<U <self>>: T.class_of(B) = cast(<U <self>>: NilClass, T.class_of(B));\l<U <block-pre-call-temp>>$4: Sorbet::Private::Static::Void = <U <self>>: T.class_of(B).<U sig>()\l<U <selfRestore>>$5: T.class_of(B) = <U <self>>\l<unconditional>\l"
    ];

    "bb::<Class:B>#<static-init>_0" -> "bb::<Class:B>#<static-init>_2" [style="bold"];
    "bb::<Class:B>#<static-init>_1" [
        label = "block[id=1]()\l<unconditional>\l"
    ];

    "bb::<Class:B>#<static-init>_1" -> "bb::<Class:B>#<static-init>_1" [style="bold"];
    "bb::<Class:B>#<static-init>_2" [
        label = "block[id=2](<U <self>>: T.class_of(B), <U <selfRestore>>$5: T.class_of(B))\louterLoops: 1\l<U <block-call>>: NilClass\l"
    ];

    "bb::<Class:B>#<static-init>_2" -> "bb::<Class:B>#<static-init>_5" [style="bold"];
    "bb::<Class:B>#<static-init>_2" -> "bb::<Class:B>#<static-init>_3" [style="tapered"];

    "bb::<Class:B>#<static-init>_3" [
        label = "block[id=3](<U <selfRestore>>$5: T.class_of(B))\l<U <returnMethodTemp>>$2: Sorbet::Private::Static::Void = Solve<::<Class:B>#<static-init>#<block>>\l<U <self>>: T.class_of(B) = <U <selfRestore>>$5\l<U <finalReturn>>: T.noreturn = return <U <returnMethodTemp>>$2: Sorbet::Private::Static::Void\l<unconditional>\l"
    ];

    "bb::<Class:B>#<static-init>_3" -> "bb::<Class:B>#<static-init>_1" [style="bold"];
    "bb::<Class:B>#<static-init>_5" [
        label = "block[id=5](<U <self>>: T.class_of(B), <U <selfRestore>>$5: T.class_of(B))\louterLoops: 1\l<U <self>>: T::Private::Methods::SigBuilder = loadSelf\l<U <statTemp>>$11: T.class_of(T) = alias <C <U T>>\l<U <statTemp>>$10: T.untyped = <U <statTemp>>$11: T.class_of(T).<U self_type>()\l<U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder = <U <self>>: T::Private::Methods::SigBuilder.<U returns>(<U <statTemp>>$10: T.untyped)\l<U <blockReturnTemp>>$12: T.noreturn = blockreturn<::<Class:B>#<static-init>#<block>> <U <blockReturnTemp>>$8: T::Private::Methods::SigBuilder\l<unconditional>\l"
    ];

    "bb::<Class:B>#<static-init>_5" -> "bb::<Class:B>#<static-init>_2" [style="bold"];
}

}

