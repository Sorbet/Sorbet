class <emptyTree><<C <U <root>>>> < ()
  class <emptyTree>::<C <U NotAODM>><<C <U <todo sym>>>> < (::<todo sym>)
    def self.<U prop><<C <U <todo sym>>>>(*<U args>, &<U <blk>>)
      <emptyTree>
    end

    <U <self>>.<U prop>()

    <U <self>>.<U prop>(:"foo", :"not_a_string")

    <U <self>>.<U prop>("not_a_symbol", <emptyTree>::<C <U String>>)

    <U <self>>.<U prop>(:"foo", <emptyTree>::<C <U String>>, "not_a_hash")

    <U <self>>.<U prop>("too", <emptyTree>::<C <U String>>, {}, "many")

    <U <self>>.<U optional>(:"company_name", <emptyTree>::<C <U String>>, :"nonempty_string")

    <U <self>>.<U optional>(:"day", <emptyTree>::<C <U IntegerParam>>.<U new>({:"min" => 1, :"max" => 31}))

    <U <self>>.<U optional>(:"name", <emptyTree>::<C <U StringParam>>.<U alphanumeric>())

    <U <self>>.<U optional>(:"how_many", <emptyTree>::<C <U Opus>>::<C <U Param>>::<C <U CaseParam>>.<U new>(<U <self>>.<U how_many_cases>(), <emptyTree>::<C <U Opus>>::<C <U Param>>::<C <U ParamSpecsParam>>.<U new>(<emptyTree>::<C <U Default>>)))

    <U <self>>.<U optional>(:"optional_param", <emptyTree>::<C <U IntegerParam>>.<U new>())
  end

  class <emptyTree>::<C <U SomeODM>><<C <U <todo sym>>>> < (::<todo sym>)
    <U <self>>.<U extend>(<emptyTree>::<C <U T>>::<C <U Sig>>)

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    <U <self>>.<U sig>() do ||
      <U <self>>.<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U foo2><<C <U <todo sym>>>>(&<U <blk>>)
      <emptyTree>::<C <U T>>.<U cast>(<emptyTree>::<C <U T>>.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    <U <self>>.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foo2=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      <emptyTree>::<C <U T>>.<U cast>(nil, <emptyTree>::<C <U String>>)
    end
  end

  class <emptyTree>::<C <U ForeignClass>><<C <U <todo sym>>>> < (::<todo sym>)
    <emptyTree>
  end

  class <emptyTree>::<C <U AdvancedODM>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U default><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U default=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U t_nilable><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U t_nilable=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U type><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U type=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::Object)
    end

    def <U object><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Object)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => ::Object}).<U returns>(::Object)
    end

    def <U object=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Object)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
      end

      def <U array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
      end

      ::Sorbet.<U sig>() do ||
        <U <self>>.<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end

      def <U array><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U array_of><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => ::T::Array.<U []>(<emptyTree>::<C <U String>>)}).<U returns>(::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U array_of=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T::Array.<U []>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array_of_explicit><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U array_of_explicit=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
      end

      def <U array_of_explicit=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
      end

      ::Sorbet.<U sig>() do ||
        <U <self>>.<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end

      def <U array_of_explicit><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U t_array><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    def <U t_array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
      end

      def <U t_array=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Array>>.<U []>(<emptyTree>::<C <U String>>))
      end

      ::Sorbet.<U sig>() do ||
        <U <self>>.<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(<emptyTree>::<C <U String>>))
      end

      def <U t_array><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(<emptyTree>::<C <U String>>))
      end
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    def <U hash_of><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    def <U hash_of=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end

      def <U hash_of=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>::<C <U Hash>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end

      ::Sorbet.<U sig>() do ||
        <U <self>>.<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U HashMutator>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end

      def <U hash_of><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U HashMutator>>.<U []>(<emptyTree>::<C <U Symbol>>, <emptyTree>::<C <U String>>))
      end
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U const_explicit><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U const><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U Array>>)
    end

    def <U no_class_arg><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
    end

    class <emptyTree>::<C <U Mutator>><<C <U <todo sym>>>> < ()
      ::Sorbet.<U sig>() do ||
        <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U Array>>}).<U returns>(<emptyTree>::<C <U Array>>)
      end

      def <U no_class_arg=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U Array>>)
      end

      ::Sorbet.<U sig>() do ||
        <U <self>>.<U returns>(::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end

      def <U no_class_arg><<C <U <todo sym>>>>(&<U <blk>>)
        ::T.<U cast>(::T.<U unsafe>(nil), ::<root>::<C <U Chalk>>::<C <U ODM>>::<C <U Mutator>>::<C <U Private>>::<C <U ArrayMutator>>.<U []>(::T.<U untyped>()))
      end
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::T.<U untyped>())
    end

    def <U enum_prop><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
    end

    def <U foreign_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(<emptyTree>::<C <U ForeignClass>>)
    end

    def <U foreign_!><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_lazy><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_lazy=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
    end

    def <U foreign_lazy_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(<emptyTree>::<C <U ForeignClass>>)
    end

    def <U foreign_lazy_!><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_proc><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_proc=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U ForeignClass>>))
    end

    def <U foreign_proc_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(<emptyTree>::<C <U ForeignClass>>)
    end

    def <U foreign_proc_!><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_invalid><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U foreign_invalid=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U untyped>())
    end

    def <U foreign_invalid_><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"opts" => ::T.<U untyped>()}).<U returns>(::T.<U untyped>())
    end

    def <U foreign_invalid_!><<C <U <todo sym>>>>(*<U opts>:, &<U <blk>>)
      ::T.<U unsafe>(nil)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U ifunset><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U String>>}).<U returns>(<emptyTree>::<C <U String>>)
    end

    def <U ifunset=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U String>>)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U ifunset_nilable><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>)}).<U returns>(<emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end

    def <U ifunset_nilable=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), <emptyTree>::<C <U T>>.<U nilable>(<emptyTree>::<C <U String>>))
    end
  end

  class <emptyTree>::<C <U PropHelpers>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::String)
    end

    def <U token><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => ::String}).<U returns>(::String)
    end

    def <U token=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::Float)
    end

    def <U created><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Float)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => ::Float}).<U returns>(::Float)
    end

    def <U created=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Float)
    end
  end

  class <emptyTree>::<C <U PropHelpers2>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::String)
    end

    def <U token><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => ::String}).<U returns>(::String)
    end

    def <U token=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::Float)
    end

    def <U created><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::Float)
    end
  end

  class <emptyTree>::<C <U ShardingProp>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::String)
    end

    def <U merchant><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::String)
    end
  end

  class <emptyTree>::<C <U EncryptedProp>><<C <U <todo sym>>>> < (::<todo sym>)
    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::T.<U nilable>(::String))
    end

    def <U foo><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(::String))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    def <U encrypted_foo><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => ::T.<U nilable>(::String)}).<U returns>(::T.<U nilable>(::String))
    end

    def <U foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(::String))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({:"arg0" => ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>)}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    def <U encrypted_foo=><<C <U <todo sym>>>>(<U arg0>, &<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::T.<U nilable>(::String))
    end

    def <U bar><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(::String))
    end

    ::Sorbet.<U sig>() do ||
      <U <self>>.<U params>({}).<U returns>(::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end

    def <U encrypted_bar><<C <U <todo sym>>>>(&<U <blk>>)
      ::T.<U cast>(::T.<U unsafe>(nil), ::T.<U nilable>(<emptyTree>::<C <U Opus>>::<C <U DB>>::<C <U Model>>::<C <U Mixins>>::<C <U Encryptable>>::<C <U EncryptedValue>>))
    end
  end

  def <U main><<C <U <todo sym>>>>(&<U <blk>>)
    begin
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo=>("b"))
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo2>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U SomeODM>>.<U new>().<U foo2=>("b"))
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U default>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U t_nilable>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U type>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U object>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U array>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U array_of>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U array_of_explicit>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U t_array>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U hash_of>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U const_explicit>())
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U const_explicit=>("b")
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U const>())
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U const=>("b")
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U no_class_arg>())
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U no_class_arg=>(["b"])
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U enum_prop>())
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U enum_prop=>("hello")
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_!>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_lazy_>())
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U foreign_invalid_>()
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U PropHelpers>>.<U new>().<U token>())
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U token=>("tok_token")
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U token=>(nil)
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U PropHelpers>>.<U new>().<U created>())
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U created=>(0.000000)
      <emptyTree>::<C <U PropHelpers>>.<U new>().<U created=>(nil)
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U PropHelpers2>>.<U new>().<U token>())
      <emptyTree>::<C <U PropHelpers2>>.<U new>().<U token=>("tok_token")
      <emptyTree>::<C <U PropHelpers2>>.<U new>().<U token=>(nil)
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U PropHelpers2>>.<U new>().<U created>())
      <emptyTree>::<C <U PropHelpers2>>.<U new>().<U created=>(0.000000)
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U ShardingProp>>.<U new>().<U merchant>())
      <emptyTree>::<C <U ShardingProp>>.<U new>().<U merchant=>("hi")
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U EncryptedProp>>.<U new>().<U foo>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U EncryptedProp>>.<U new>().<U encrypted_foo>())
      <emptyTree>::<C <U EncryptedProp>>.<U new>().<U foo=>("hello")
      <emptyTree>::<C <U EncryptedProp>>.<U new>().<U foo=>(nil)
      <emptyTree>::<C <U EncryptedProp>>.<U new>().<U bar=>("hello")
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset>())
      <emptyTree>::<C <U T>>.<U reveal_type>(<emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset_nilable>())
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset=>(nil)
      <emptyTree>::<C <U AdvancedODM>>.<U new>().<U ifunset_nilable=>(nil)
    end
  end
end
