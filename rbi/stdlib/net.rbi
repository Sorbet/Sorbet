# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   scripts/bin/remote-script sorbet/shim_generation/gems.rb -r net

# typed: true

module Net
end

class Net::BufferedIO
  BUFSIZE = ::T.let(nil, ::T.untyped)

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig {returns(::T.untyped)}
  def continue_timeout(); end

  sig do
    params(
      continue_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def continue_timeout=(continue_timeout); end

  sig {returns(::T.untyped)}
  def debug_output(); end

  sig do
    params(
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(debug_output); end

  sig {returns(::T.untyped)}
  def eof?(); end

  sig do
    params(
      io: ::T.untyped,
      read_timeout: ::T.untyped,
      continue_timeout: ::T.untyped,
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(io, read_timeout: T.unsafe(nil), continue_timeout: T.unsafe(nil), debug_output: T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def io(); end

  sig do
    params(
      len: ::T.untyped,
      dest: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(len, dest=T.unsafe(nil), ignore_eof=T.unsafe(nil)); end

  sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_all(dest=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def read_timeout(); end

  sig do
    params(
      read_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(read_timeout); end

  sig {returns(::T.untyped)}
  def readline(); end

  sig do
    params(
      terminator: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def readuntil(terminator, ignore_eof=T.unsafe(nil)); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(str); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def writeline(str); end
end

class Net::FTP < Net::Protocol
  include ::OpenSSL::SSL
  include ::OpenSSL
  include ::MonitorMixin
  CASE_DEPENDENT_PARSER = ::T.let(nil, ::T.untyped)
  CASE_INDEPENDENT_PARSER = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  DECIMAL_PARSER = ::T.let(nil, ::T.untyped)
  DEFAULT_BLOCKSIZE = ::T.let(nil, ::T.untyped)
  FACT_PARSERS = ::T.let(nil, ::T.untyped)
  FTP_PORT = ::T.let(nil, ::T.untyped)
  OCTAL_PARSER = ::T.let(nil, ::T.untyped)
  TIME_PARSER = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def abort(); end

  sig do
    params(
      account: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def acct(account); end

  sig {returns(::T.untyped)}
  def binary(); end

  sig do
    params(
      newmode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def binary=(newmode); end

  sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def chdir(dirname); end

  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig do
    params(
      host: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connect(host, port=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def debug_mode(); end

  sig do
    params(
      debug_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_mode=(debug_mode); end

  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(filename); end

  sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dir(*args, &block); end

  sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get(remotefile, localfile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getbinaryfile(remotefile, localfile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def getdir(); end

  sig do
    params(
      remotefile: ::T.untyped,
      localfile: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def gettextfile(remotefile, localfile=T.unsafe(nil), &block); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def help(arg=T.unsafe(nil)); end

  sig do
    params(
      host: ::T.untyped,
      user_or_options: ::T.untyped,
      passwd: ::T.untyped,
      acct: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host=T.unsafe(nil), user_or_options=T.unsafe(nil), passwd=T.unsafe(nil), acct=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def last_response(); end

  sig {returns(::T.untyped)}
  def last_response_code(); end

  sig {returns(::T.untyped)}
  def lastresp(); end

  sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def list(*args, &block); end

  sig do
    params(
      user: ::T.untyped,
      passwd: ::T.untyped,
      acct: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def login(user=T.unsafe(nil), passwd=T.unsafe(nil), acct=T.unsafe(nil)); end

  sig do
    params(
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ls(*args, &block); end

  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mdtm(filename); end

  sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkdir(dirname); end

  sig do
    params(
      pathname: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mlsd(pathname=T.unsafe(nil), &block); end

  sig do
    params(
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mlst(pathname=T.unsafe(nil)); end

  sig do
    params(
      filename: ::T.untyped,
      local: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mtime(filename, local=T.unsafe(nil)); end

  sig do
    params(
      dir: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def nlst(dir=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def noop(); end

  sig {returns(::T.untyped)}
  def open_timeout(); end

  sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  sig {returns(::T.untyped)}
  def passive(); end

  sig do
    params(
      passive: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def passive=(passive); end

  sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put(localfile, remotefile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      blocksize: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def putbinaryfile(localfile, remotefile=T.unsafe(nil), blocksize=T.unsafe(nil), &block); end

  sig do
    params(
      localfile: ::T.untyped,
      remotefile: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puttextfile(localfile, remotefile=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def pwd(); end

  sig {returns(::T.untyped)}
  def quit(); end

  sig {returns(::T.untyped)}
  def read_timeout(); end

  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  sig do
    params(
      fromname: ::T.untyped,
      toname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(fromname, toname); end

  sig {returns(::T.untyped)}
  def resume(); end

  sig do
    params(
      resume: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def resume=(resume); end

  sig do
    params(
      cmd: ::T.untyped,
      blocksize: ::T.untyped,
      rest_offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrbinary(cmd, blocksize, rest_offset=T.unsafe(nil)); end

  sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retrlines(cmd); end

  sig {returns(::T.untyped)}
  def return_code(); end

  sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def return_code=(s); end

  sig do
    params(
      dirname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rmdir(dirname); end

  sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sendcmd(cmd); end

  sig do
    params(
      sock: ::T.untyped,
      get_greeting: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_socket(sock, get_greeting=T.unsafe(nil)); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def site(arg); end

  sig do
    params(
      filename: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size(filename); end

  sig {returns(::T.untyped)}
  def ssl_handshake_timeout(); end

  sig do
    params(
      ssl_handshake_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_handshake_timeout=(ssl_handshake_timeout); end

  sig do
    params(
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def status(pathname=T.unsafe(nil)); end

  sig do
    params(
      cmd: ::T.untyped,
      file: ::T.untyped,
      blocksize: ::T.untyped,
      rest_offset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def storbinary(cmd, file, blocksize, rest_offset=T.unsafe(nil)); end

  sig do
    params(
      cmd: ::T.untyped,
      file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def storlines(cmd, file); end

  sig {returns(::T.untyped)}
  def system(); end

  sig do
    params(
      cmd: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def voidcmd(cmd); end

  sig {returns(::T.untyped)}
  def welcome(); end

  sig {returns(::T.untyped)}
  def self.default_passive(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.default_passive=(value); end

  sig do
    params(
      host: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.open(host, *args); end
end

class Net::FTP::BufferedSSLSocket < Net::FTP::BufferedSocket
  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*args); end

  sig do
    params(
      mesg: ::T.untyped,
      flags: ::T.untyped,
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send(mesg, flags, dest=T.unsafe(nil)); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(*args); end
end

class Net::FTP::BufferedSocket < Net::BufferedIO
  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def addr(*args); end

  sig {returns(::T.untyped)}
  def gets(); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_address(*args); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def peeraddr(*args); end

  sig do
    params(
      len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(len=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def readline(); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remote_address(*args); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send(*args); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(*args); end
end

class Net::FTP::MLSxEntry
  sig {returns(::T.untyped)}
  def appendable?(); end

  sig {returns(::T.untyped)}
  def charset(); end

  sig {returns(::T.untyped)}
  def creatable?(); end

  sig {returns(::T.untyped)}
  def create(); end

  sig {returns(::T.untyped)}
  def deletable?(); end

  sig {returns(::T.untyped)}
  def directory?(); end

  sig {returns(::T.untyped)}
  def directory_makable?(); end

  sig {returns(::T.untyped)}
  def enterable?(); end

  sig {returns(::T.untyped)}
  def facts(); end

  sig {returns(::T.untyped)}
  def file?(); end

  sig do
    params(
      facts: ::T.untyped,
      pathname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(facts, pathname); end

  sig {returns(::T.untyped)}
  def lang(); end

  sig {returns(::T.untyped)}
  def listable?(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig {returns(::T.untyped)}
  def modify(); end

  sig {returns(::T.untyped)}
  def pathname(); end

  sig {returns(::T.untyped)}
  def perm(); end

  sig {returns(::T.untyped)}
  def purgeable?(); end

  sig {returns(::T.untyped)}
  def readable?(); end

  sig {returns(::T.untyped)}
  def renamable?(); end

  sig {returns(::T.untyped)}
  def size(); end

  sig {returns(::T.untyped)}
  def type(); end

  sig {returns(::T.untyped)}
  def unique(); end

  sig {returns(::T.untyped)}
  def writable?(); end
end

class Net::FTP::NullSocket
  sig {returns(::T.untyped)}
  def close(); end

  sig {returns(::T.untyped)}
  def closed?(); end

  sig do
    params(
      mid: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def method_missing(mid, *args); end

  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end
end

class Net::FTPConnectionError < Net::FTPError
end

class Net::FTPError < StandardError
end

class Net::FTPPermError < Net::FTPError
end

class Net::FTPProtoError < Net::FTPError
end

class Net::FTPReplyError < Net::FTPError
end

class Net::FTPTempError < Net::FTPError
end

class Net::HTTP < Net::Protocol
  HAVE_ZLIB = ::T.let(nil, ::T.untyped)
  HTTPVersion = ::T.let(nil, ::T.untyped)
  IDEMPOTENT_METHODS_ = ::T.let(nil, ::T.untyped)
  Revision = ::T.let(nil, ::T.untyped)
  SSL_ATTRIBUTES = ::T.let(nil, ::T.untyped)
  SSL_IVNAMES = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def active?(); end

  sig {returns(::T.untyped)}
  def address(); end

  sig {returns(::T.untyped)}
  def ca_file(); end

  sig do
    params(
      ca_file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_file=(ca_file); end

  sig {returns(::T.untyped)}
  def ca_path(); end

  sig do
    params(
      ca_path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_path=(ca_path); end

  sig {returns(::T.untyped)}
  def cert(); end

  sig do
    params(
      cert: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert=(cert); end

  sig {returns(::T.untyped)}
  def cert_store(); end

  sig do
    params(
      cert_store: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert_store=(cert_store); end

  sig {returns(::T.untyped)}
  def ciphers(); end

  sig do
    params(
      ciphers: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ciphers=(ciphers); end

  sig {returns(::T.untyped)}
  def close_on_empty_response(); end

  sig do
    params(
      close_on_empty_response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def close_on_empty_response=(close_on_empty_response); end

  sig {returns(::T.untyped)}
  def continue_timeout(); end

  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def continue_timeout=(sec); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy(path, initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(path, initheader=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get(path, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get2(path, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def head(path, initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def head2(path, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def keep_alive_timeout(); end

  sig do
    params(
      keep_alive_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def keep_alive_timeout=(keep_alive_timeout); end

  sig {returns(::T.untyped)}
  def key(); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  sig {returns(::T.untyped)}
  def local_host(); end

  sig do
    params(
      local_host: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_host=(local_host); end

  sig {returns(::T.untyped)}
  def local_port(); end

  sig do
    params(
      local_port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def local_port=(local_port); end

  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lock(path, body, initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mkcol(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def move(path, initheader=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def open_timeout(); end

  sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def options(path, initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def patch(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def peer_cert(); end

  sig {returns(::T.untyped)}
  def port(); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def post(path, data, initheader=T.unsafe(nil), dest=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def post2(path, data, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def propfind(path, body=T.unsafe(nil), initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proppatch(path, body, initheader=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def proxy?(); end

  sig {returns(::T.untyped)}
  def proxy_address(); end

  sig do
    params(
      proxy_address: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_address=(proxy_address); end

  sig do
    params(
      proxy_from_env: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_from_env=(proxy_from_env); end

  sig {returns(::T.untyped)}
  def proxy_from_env?(); end

  sig {returns(::T.untyped)}
  def proxy_pass(); end

  sig do
    params(
      proxy_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_pass=(proxy_pass); end

  sig {returns(::T.untyped)}
  def proxy_port(); end

  sig do
    params(
      proxy_port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_port=(proxy_port); end

  sig {returns(::T.untyped)}
  def proxy_uri(); end

  sig {returns(::T.untyped)}
  def proxy_user(); end

  sig do
    params(
      proxy_user: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_user=(proxy_user); end

  sig {returns(::T.untyped)}
  def proxyaddr(); end

  sig {returns(::T.untyped)}
  def proxyport(); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put(path, data, initheader=T.unsafe(nil)); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def put2(path, data, initheader=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def read_timeout(); end

  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  sig do
    params(
      req: ::T.untyped,
      body: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request(req, body=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_get(path, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_head(path, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_post(path, data, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      path: ::T.untyped,
      data: ::T.untyped,
      initheader: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_put(path, data, initheader=T.unsafe(nil), &block); end

  sig do
    params(
      name: ::T.untyped,
      path: ::T.untyped,
      data: ::T.untyped,
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_request(name, path, data=T.unsafe(nil), header=T.unsafe(nil)); end

  sig do
    params(
      output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_debug_output(output); end

  sig {returns(::T.untyped)}
  def ssl_timeout(); end

  sig do
    params(
      ssl_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_timeout=(ssl_timeout); end

  sig {returns(::T.untyped)}
  def ssl_version(); end

  sig do
    params(
      ssl_version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_version=(ssl_version); end

  sig {returns(::T.untyped)}
  def start(); end

  sig {returns(::T.untyped)}
  def started?(); end

  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def trace(path, initheader=T.unsafe(nil)); end

  sig do
    params(
      req: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def transport_request(req); end

  sig do
    params(
      path: ::T.untyped,
      body: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unlock(path, body, initheader=T.unsafe(nil)); end

  sig do
    params(
      flag: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def use_ssl=(flag); end

  sig {returns(::T.untyped)}
  def use_ssl?(); end

  sig {returns(::T.untyped)}
  def verify_callback(); end

  sig do
    params(
      verify_callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_callback=(verify_callback); end

  sig {returns(::T.untyped)}
  def verify_depth(); end

  sig do
    params(
      verify_depth: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_depth=(verify_depth); end

  sig {returns(::T.untyped)}
  def verify_mode(); end

  sig do
    params(
      verify_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_mode=(verify_mode); end

  sig do
    params(
      p_addr: ::T.untyped,
      p_port: ::T.untyped,
      p_user: ::T.untyped,
      p_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.Proxy(p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def self.default_port(); end

  sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil)); end

  sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_print(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil)); end

  sig do
    params(
      uri_or_host: ::T.untyped,
      path: ::T.untyped,
      port: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.get_response(uri_or_host, path=T.unsafe(nil), port=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def self.http_default_port(); end

  sig {returns(::T.untyped)}
  def self.https_default_port(); end

  sig {returns(::T.untyped)}
  def self.is_version_1_1?(); end

  sig {returns(::T.untyped)}
  def self.is_version_1_2?(); end

  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
      p_addr: ::T.untyped,
      p_port: ::T.untyped,
      p_user: ::T.untyped,
      p_pass: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(address, port=T.unsafe(nil), p_addr=T.unsafe(nil), p_port=T.unsafe(nil), p_user=T.unsafe(nil), p_pass=T.unsafe(nil)); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.newobj(*_); end

  sig do
    params(
      url: ::T.untyped,
      data: ::T.untyped,
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.post(url, data, header=T.unsafe(nil)); end

  sig do
    params(
      url: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.post_form(url, params); end

  sig {returns(::T.untyped)}
  def self.proxy_address(); end

  sig {returns(::T.untyped)}
  def self.proxy_class?(); end

  sig {returns(::T.untyped)}
  def self.proxy_pass(); end

  sig {returns(::T.untyped)}
  def self.proxy_port(); end

  sig {returns(::T.untyped)}
  def self.proxy_user(); end

  sig {returns(::T.untyped)}
  def self.socket_type(); end

  sig do
    params(
      address: ::T.untyped,
      arg: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(address, *arg, &block); end

  sig {returns(::T.untyped)}
  def self.version_1_1?(); end

  sig {returns(::T.untyped)}
  def self.version_1_2(); end

  sig {returns(::T.untyped)}
  def self.version_1_2?(); end
end

class Net::HTTP::Copy < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Delete < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::DigestAuth
  include ::MonitorMixin
  VERSION = ::T.let(nil, ::T.untyped)

  sig do
    params(
      uri: ::T.untyped,
      www_authenticate: ::T.untyped,
      method: ::T.untyped,
      iis: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_header(uri, www_authenticate, method, iis=T.unsafe(nil)); end

  sig do
    params(
      ignored: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(ignored=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def make_cnonce(); end

  sig {returns(::T.untyped)}
  def next_nonce(); end
end

class Net::HTTP::DigestAuth::Error < RuntimeError
end

class Net::HTTP::Get < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Head < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Lock < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Mkcol < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Move < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Options < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Patch < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Persistent
  EPOCH = ::T.let(nil, ::T.untyped)
  HAVE_OPENSSL = ::T.let(nil, ::T.untyped)
  RETRIED_EXCEPTIONS = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def ca_file(); end

  sig do
    params(
      file: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ca_file=(file); end

  sig do
    params(
      req: ::T.untyped,
      retried_on_ruby_2: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def can_retry?(req, retried_on_ruby_2=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def cert(); end

  sig do
    params(
      certificate: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert=(certificate); end

  sig {returns(::T.untyped)}
  def cert_store(); end

  sig do
    params(
      store: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cert_store=(store); end

  sig {returns(::T.untyped)}
  def certificate(); end

  sig do
    params(
      certificate: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def certificate=(certificate); end

  sig do
    params(
      generation: ::T.untyped,
      thread: ::T.untyped,
      generation_key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cleanup(generation, thread=T.unsafe(nil), generation_key=T.unsafe(nil)); end

  sig do
    params(
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connection_close?(header); end

  sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connection_for(uri); end

  sig do
    params(
      header: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def connection_keep_alive?(header); end

  sig {returns(::T.untyped)}
  def debug_output(); end

  sig do
    params(
      debug_output: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(debug_output); end

  sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def error_message(connection); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def escape(str); end

  sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def expired?(connection); end

  sig do
    params(
      connection: ::T.untyped,
      thread: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def finish(connection, thread=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def generation(); end

  sig {returns(::T.untyped)}
  def generation_key(); end

  sig {returns(::T.untyped)}
  def headers(); end

  sig {returns(::T.untyped)}
  def http_class(); end

  sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def http_version(uri); end

  sig {returns(::T.untyped)}
  def http_versions(); end

  sig do
    params(
      req: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def idempotent?(req); end

  sig {returns(::T.untyped)}
  def idle_timeout(); end

  sig do
    params(
      idle_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def idle_timeout=(idle_timeout); end

  sig do
    params(
      name: ::T.untyped,
      proxy: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(name=T.unsafe(nil), proxy=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def keep_alive(); end

  sig do
    params(
      keep_alive: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def keep_alive=(keep_alive); end

  sig {returns(::T.untyped)}
  def key(); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key=(key); end

  sig {returns(::T.untyped)}
  def max_age(); end

  sig {returns(::T.untyped)}
  def max_requests(); end

  sig do
    params(
      max_requests: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def max_requests=(max_requests); end

  sig {returns(::T.untyped)}
  def name(); end

  sig {returns(::T.untyped)}
  def no_proxy(); end

  sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def normalize_uri(uri); end

  sig {returns(::T.untyped)}
  def open_timeout(); end

  sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  sig {returns(::T.untyped)}
  def override_headers(); end

  sig do
    params(
      uri: ::T.untyped,
      requests: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def pipeline(uri, requests, &block); end

  sig {returns(::T.untyped)}
  def private_key(); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def private_key=(key); end

  sig do
    params(
      proxy: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy=(proxy); end

  sig do
    params(
      host: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_bypass?(host, port); end

  sig {returns(::T.untyped)}
  def proxy_from_env(); end

  sig {returns(::T.untyped)}
  def proxy_uri(); end

  sig {returns(::T.untyped)}
  def read_timeout(); end

  sig do
    params(
      read_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(read_timeout); end

  sig {returns(::T.untyped)}
  def reconnect(); end

  sig {returns(::T.untyped)}
  def reconnect_ssl(); end

  sig do
    params(
      uri: ::T.untyped,
      req: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request(uri, req=T.unsafe(nil), &block); end

  sig do
    params(
      exception: ::T.untyped,
      req: ::T.untyped,
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_failed(exception, req, connection); end

  sig {returns(::T.untyped)}
  def request_key(); end

  sig do
    params(
      req_or_uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def request_setup(req_or_uri); end

  sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reset(connection); end

  sig {returns(::T.untyped)}
  def retry_change_requests(); end

  sig do
    params(
      retry_change_requests: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def retry_change_requests=(retry_change_requests); end

  sig {returns(::T.untyped)}
  def reuse_ssl_sessions(); end

  sig do
    params(
      reuse_ssl_sessions: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reuse_ssl_sessions=(reuse_ssl_sessions); end

  sig do
    params(
      thread: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def shutdown(thread=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def shutdown_in_all_threads(); end

  sig {returns(::T.untyped)}
  def socket_options(); end

  sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl(connection); end

  sig do
    params(
      generation: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_cleanup(generation); end

  sig {returns(::T.untyped)}
  def ssl_generation(); end

  sig {returns(::T.untyped)}
  def ssl_generation_key(); end

  sig {returns(::T.untyped)}
  def ssl_version(); end

  sig do
    params(
      ssl_version: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ssl_version=(ssl_version); end

  sig do
    params(
      connection: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def start(connection); end

  sig {returns(::T.untyped)}
  def timeout_key(); end

  sig {returns(::T.untyped)}
  def verify_callback(); end

  sig do
    params(
      callback: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_callback=(callback); end

  sig {returns(::T.untyped)}
  def verify_mode(); end

  sig do
    params(
      verify_mode: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def verify_mode=(verify_mode); end

  sig do
    params(
      uri: ::T.untyped,
      max: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.detect_idle_timeout(uri, max=T.unsafe(nil)); end
end

class Net::HTTP::Persistent::Error < StandardError
end

class Net::HTTP::Persistent::SSLReuse < Net::HTTP
  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end
end

class Net::HTTP::Post < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Propfind < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Proppatch < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

module Net::HTTP::ProxyDelta
end

class Net::HTTP::Put < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Trace < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTP::Unlock < Net::HTTPRequest
  METHOD = ::T.let(nil, ::T.untyped)
  REQUEST_HAS_BODY = ::T.let(nil, ::T.untyped)
  RESPONSE_HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPAccepted < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPBadGateway < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPBadRequest < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPBadResponse < StandardError
end

class Net::HTTPClientError < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPConflict < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPContinue < Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPCreated < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPError < Net::ProtocolError
  include ::Net::HTTPExceptions
end

module Net::HTTPExceptions
  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      msg: ::T.untyped,
      res: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(msg, res); end

  sig {returns(::T.untyped)}
  def response(); end
end

class Net::HTTPExpectationFailed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPFailedDependency < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPFatalError < Net::ProtoFatalError
  include ::Net::HTTPExceptions
end

class Net::HTTPForbidden < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPFound < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPGatewayTimeOut < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPGenericRequest
  include ::Net::HTTPHeader
  sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, val); end

  sig {returns(::T.untyped)}
  def body(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(str); end

  sig {returns(::T.untyped)}
  def body_exist?(); end

  sig {returns(::T.untyped)}
  def body_stream(); end

  sig do
    params(
      input: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body_stream=(input); end

  sig {returns(::T.untyped)}
  def decode_content(); end

  sig do
    params(
      sock: ::T.untyped,
      ver: ::T.untyped,
      path: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def exec(sock, ver, path); end

  sig do
    params(
      m: ::T.untyped,
      reqbody: ::T.untyped,
      resbody: ::T.untyped,
      uri_or_path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(m, reqbody, resbody, uri_or_path, initheader=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def method(); end

  sig {returns(::T.untyped)}
  def path(); end

  sig {returns(::T.untyped)}
  def request_body_permitted?(); end

  sig {returns(::T.untyped)}
  def response_body_permitted?(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_body_internal(str); end

  sig do
    params(
      addr: ::T.untyped,
      port: ::T.untyped,
      ssl: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def update_uri(addr, port, ssl); end

  sig {returns(::T.untyped)}
  def uri(); end
end

class Net::HTTPGenericRequest::Chunker
  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      sock: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(sock); end

  sig do
    params(
      buf: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(buf); end
end

class Net::HTTPGone < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

module Net::HTTPHeader
  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def [](key); end

  sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def []=(key, val); end

  sig do
    params(
      key: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_field(key, val); end

  sig do
    params(
      account: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def basic_auth(account, password); end

  sig {returns(::T.untyped)}
  def canonical_each(); end

  sig {returns(::T.untyped)}
  def chunked?(); end

  sig {returns(::T.untyped)}
  def connection_close?(); end

  sig {returns(::T.untyped)}
  def connection_keep_alive?(); end

  sig {returns(::T.untyped)}
  def content_length(); end

  sig do
    params(
      len: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_length=(len); end

  sig {returns(::T.untyped)}
  def content_range(); end

  sig {returns(::T.untyped)}
  def content_type(); end

  sig do
    params(
      type: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_type=(type, params=T.unsafe(nil)); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(key); end

  sig {returns(::T.untyped)}
  def each(); end

  sig {returns(::T.untyped)}
  def each_capitalized(); end

  sig {returns(::T.untyped)}
  def each_capitalized_name(); end

  sig {returns(::T.untyped)}
  def each_header(); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_key(&block); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def each_name(&block); end

  sig {returns(::T.untyped)}
  def each_value(); end

  sig do
    params(
      key: ::T.untyped,
      args: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fetch(key, *args, &block); end

  sig do
    params(
      params: ::T.untyped,
      sep: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def form_data=(params, sep=T.unsafe(nil)); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def get_fields(key); end

  sig do
    params(
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize_http_header(initheader); end

  sig do
    params(
      key: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def key?(key); end

  sig {returns(::T.untyped)}
  def length(); end

  sig {returns(::T.untyped)}
  def main_type(); end

  sig do
    params(
      account: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def proxy_basic_auth(account, password); end

  sig {returns(::T.untyped)}
  def range(); end

  sig do
    params(
      r: ::T.untyped,
      e: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def range=(r, e=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def range_length(); end

  sig do
    params(
      type: ::T.untyped,
      params: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_content_type(type, params=T.unsafe(nil)); end

  sig do
    params(
      params: ::T.untyped,
      enctype: ::T.untyped,
      formopt: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_form(params, enctype=T.unsafe(nil), formopt=T.unsafe(nil)); end

  sig do
    params(
      params: ::T.untyped,
      sep: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_form_data(params, sep=T.unsafe(nil)); end

  sig do
    params(
      r: ::T.untyped,
      e: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_range(r, e=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def size(); end

  sig {returns(::T.untyped)}
  def sub_type(); end

  sig {returns(::T.untyped)}
  def to_hash(); end

  sig {returns(::T.untyped)}
  def type_params(); end
end

class Net::HTTPHeaderSyntaxError < StandardError
end

class Net::HTTPIMUsed < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPInformation < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPInsufficientStorage < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPInternalServerError < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPLengthRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPLocked < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMethodNotAllowed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMovedPermanently < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMultiStatus < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPMultipleChoices < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNetworkAuthenticationRequired < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNoContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNonAuthoritativeInformation < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotAcceptable < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotFound < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotImplemented < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPNotModified < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPOK < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPartialContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPaymentRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPermanentRedirect < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPreconditionFailed < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPPreconditionRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPProxyAuthenticationRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRedirection < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequest < Net::HTTPGenericRequest
  sig do
    params(
      path: ::T.untyped,
      initheader: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(path, initheader=T.unsafe(nil)); end
end

class Net::HTTPRequestEntityTooLarge < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestHeaderFieldsTooLarge < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestTimeOut < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestURITooLong < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPRequestedRangeNotSatisfiable < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPResetContent < Net::HTTPSuccess
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPResponse
  include ::Net::HTTPHeader
  CODE_CLASS_TO_OBJ = ::T.let(nil, ::T.untyped)
  CODE_TO_OBJ = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def body(); end

  sig do
    params(
      value: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(value); end

  sig {returns(::T.untyped)}
  def code(); end

  sig {returns(::T.untyped)}
  def code_type(); end

  sig {returns(::T.untyped)}
  def decode_content(); end

  sig do
    params(
      decode_content: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def decode_content=(decode_content); end

  sig {returns(::T.untyped)}
  def entity(); end

  sig {returns(::T.untyped)}
  def error!(); end

  sig {returns(::T.untyped)}
  def error_type(); end

  sig {returns(::T.untyped)}
  def header(); end

  sig {returns(::T.untyped)}
  def http_version(); end

  sig do
    params(
      httpv: ::T.untyped,
      code: ::T.untyped,
      msg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(httpv, code, msg); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig {returns(::T.untyped)}
  def message(); end

  sig {returns(::T.untyped)}
  def msg(); end

  sig do
    params(
      dest: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_body(dest=T.unsafe(nil), &block); end

  sig {returns(::T.untyped)}
  def read_header(); end

  sig do
    params(
      sock: ::T.untyped,
      reqmethodallowbody: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reading_body(sock, reqmethodallowbody); end

  sig {returns(::T.untyped)}
  def response(); end

  sig {returns(::T.untyped)}
  def uri(); end

  sig do
    params(
      uri: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uri=(uri); end

  sig {returns(::T.untyped)}
  def value(); end

  sig {returns(::T.untyped)}
  def self.body_permitted?(); end

  sig {returns(::T.untyped)}
  def self.exception_type(); end

  sig do
    params(
      sock: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.read_new(sock); end
end

class Net::HTTPResponse::Inflater
  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def inflate_adapter(dest); end

  sig do
    params(
      socket: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket); end

  sig do
    params(
      clen: ::T.untyped,
      dest: ::T.untyped,
      ignore_eof: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read(clen, dest, ignore_eof=T.unsafe(nil)); end

  sig do
    params(
      dest: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_all(dest); end
end

class Net::HTTPRetriableError < Net::ProtoRetriableError
  include ::Net::HTTPExceptions
end

class Net::HTTPSeeOther < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPServerError < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPServerException < Net::ProtoServerError
  include ::Net::HTTPExceptions
end

class Net::HTTPServiceUnavailable < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPSuccess < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPSwitchProtocol < Net::HTTPInformation
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPTemporaryRedirect < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPTooManyRequests < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnauthorized < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnavailableForLegalReasons < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnknownResponse < Net::HTTPResponse
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnprocessableEntity < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUnsupportedMediaType < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUpgradeRequired < Net::HTTPClientError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPUseProxy < Net::HTTPRedirection
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::HTTPVersionNotSupported < Net::HTTPServerError
  HAS_BODY = ::T.let(nil, ::T.untyped)

end

class Net::IMAP
  include ::OpenSSL::SSL
  include ::OpenSSL
  include ::MonitorMixin
  ANSWERED = ::T.let(nil, ::T.untyped)
  CRLF = ::T.let(nil, ::T.untyped)
  DATE_MONTH = ::T.let(nil, ::T.untyped)
  DELETED = ::T.let(nil, ::T.untyped)
  DRAFT = ::T.let(nil, ::T.untyped)
  FLAGGED = ::T.let(nil, ::T.untyped)
  MARKED = ::T.let(nil, ::T.untyped)
  NOINFERIORS = ::T.let(nil, ::T.untyped)
  NOSELECT = ::T.let(nil, ::T.untyped)
  PORT = ::T.let(nil, ::T.untyped)
  RECENT = ::T.let(nil, ::T.untyped)
  SEEN = ::T.let(nil, ::T.untyped)
  SSL_PORT = ::T.let(nil, ::T.untyped)
  UNMARKED = ::T.let(nil, ::T.untyped)

  sig do
    params(
      handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def add_response_handler(handler=T.unsafe(nil)); end

  sig do
    params(
      mailbox: ::T.untyped,
      message: ::T.untyped,
      flags: ::T.untyped,
      date_time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def append(mailbox, message, flags=T.unsafe(nil), date_time=T.unsafe(nil)); end

  sig do
    params(
      auth_type: ::T.untyped,
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(auth_type, *args); end

  sig {returns(::T.untyped)}
  def capability(); end

  sig {returns(::T.untyped)}
  def check(); end

  sig {returns(::T.untyped)}
  def client_thread(); end

  sig do
    params(
      client_thread: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def client_thread=(client_thread); end

  sig {returns(::T.untyped)}
  def close(); end

  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def copy(set, mailbox); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def create(mailbox); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delete(mailbox); end

  sig {returns(::T.untyped)}
  def disconnect(); end

  sig {returns(::T.untyped)}
  def disconnected?(); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def examine(mailbox); end

  sig {returns(::T.untyped)}
  def expunge(); end

  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def fetch(set, attr); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getacl(mailbox); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getquota(mailbox); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def getquotaroot(mailbox); end

  sig {returns(::T.untyped)}
  def greeting(); end

  sig do
    params(
      timeout: ::T.untyped,
      response_handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def idle(timeout=T.unsafe(nil), &response_handler); end

  sig {returns(::T.untyped)}
  def idle_done(); end

  sig do
    params(
      host: ::T.untyped,
      port_or_options: ::T.untyped,
      usessl: ::T.untyped,
      certs: ::T.untyped,
      verify: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(host, port_or_options=T.unsafe(nil), usessl=T.unsafe(nil), certs=T.unsafe(nil), verify=T.unsafe(nil)); end

  sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def list(refname, mailbox); end

  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def login(user, password); end

  sig {returns(::T.untyped)}
  def logout(); end

  sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lsub(refname, mailbox); end

  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def move(set, mailbox); end

  sig {returns(::T.untyped)}
  def noop(); end

  sig do
    params(
      handler: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def remove_response_handler(handler); end

  sig do
    params(
      mailbox: ::T.untyped,
      newname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rename(mailbox, newname); end

  sig {returns(::T.untyped)}
  def response_handlers(); end

  sig {returns(::T.untyped)}
  def responses(); end

  sig do
    params(
      keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def search(keys, charset=T.unsafe(nil)); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def select(mailbox); end

  sig do
    params(
      mailbox: ::T.untyped,
      user: ::T.untyped,
      rights: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setacl(mailbox, user, rights); end

  sig do
    params(
      mailbox: ::T.untyped,
      quota: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def setquota(mailbox, quota); end

  sig do
    params(
      sort_keys: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sort(sort_keys, search_keys, charset); end

  sig do
    params(
      options: ::T.untyped,
      verify: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def starttls(options=T.unsafe(nil), verify=T.unsafe(nil)); end

  sig do
    params(
      mailbox: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def status(mailbox, attr); end

  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def store(set, attr, flags); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subscribe(mailbox); end

  sig do
    params(
      algorithm: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def thread(algorithm, search_keys, charset); end

  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_copy(set, mailbox); end

  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_fetch(set, attr); end

  sig do
    params(
      set: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_move(set, mailbox); end

  sig do
    params(
      keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_search(keys, charset=T.unsafe(nil)); end

  sig do
    params(
      sort_keys: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_sort(sort_keys, search_keys, charset); end

  sig do
    params(
      set: ::T.untyped,
      attr: ::T.untyped,
      flags: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_store(set, attr, flags); end

  sig do
    params(
      algorithm: ::T.untyped,
      search_keys: ::T.untyped,
      charset: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def uid_thread(algorithm, search_keys, charset); end

  sig do
    params(
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def unsubscribe(mailbox); end

  sig do
    params(
      refname: ::T.untyped,
      mailbox: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def xlist(refname, mailbox); end

  sig do
    params(
      auth_type: ::T.untyped,
      authenticator: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.add_authenticator(auth_type, authenticator); end

  sig {returns(::T.untyped)}
  def self.debug(); end

  sig do
    params(
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.debug=(val); end

  sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.decode_utf7(s); end

  sig {returns(::T.untyped)}
  def self.default_imap_port(); end

  sig {returns(::T.untyped)}
  def self.default_imaps_port(); end

  sig {returns(::T.untyped)}
  def self.default_port(); end

  sig {returns(::T.untyped)}
  def self.default_ssl_port(); end

  sig {returns(::T.untyped)}
  def self.default_tls_port(); end

  sig do
    params(
      s: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.encode_utf7(s); end

  sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.format_date(time); end

  sig do
    params(
      time: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.format_datetime(time); end

  sig {returns(::T.untyped)}
  def self.max_flag_count(); end

  sig do
    params(
      count: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.max_flag_count=(count); end
end

class Net::IMAP::Address < Struct
  sig {returns(::T.untyped)}
  def host(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def host=(_); end

  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig {returns(::T.untyped)}
  def route(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def route=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::Atom
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::BadResponseError < Net::IMAP::ResponseError
end

class Net::IMAP::BodyTypeAttachment
  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeBasic
  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  sig {returns(::T.untyped)}
  def md5(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeExtension
  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def params(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def params=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeMessage
  sig {returns(::T.untyped)}
  def body(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def body=(_); end

  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def envelope(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def envelope=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  sig {returns(::T.untyped)}
  def lines(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lines=(_); end

  sig {returns(::T.untyped)}
  def md5(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeMultipart
  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def parts(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parts=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::BodyTypeText
  sig {returns(::T.untyped)}
  def content_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def content_id=(_); end

  sig {returns(::T.untyped)}
  def description(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def description=(_); end

  sig {returns(::T.untyped)}
  def disposition(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def disposition=(_); end

  sig {returns(::T.untyped)}
  def encoding(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def encoding=(_); end

  sig {returns(::T.untyped)}
  def extension(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def extension=(_); end

  sig {returns(::T.untyped)}
  def language(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def language=(_); end

  sig {returns(::T.untyped)}
  def lines(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def lines=(_); end

  sig {returns(::T.untyped)}
  def md5(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def md5=(_); end

  sig {returns(::T.untyped)}
  def media_subtype(); end

  sig {returns(::T.untyped)}
  def media_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def media_type=(_); end

  sig {returns(::T.untyped)}
  def multipart?(); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig {returns(::T.untyped)}
  def size(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def size=(_); end

  sig {returns(::T.untyped)}
  def subtype(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subtype=(_); end
end

class Net::IMAP::ByeResponseError < Net::IMAP::ResponseError
end

class Net::IMAP::ContentDisposition < Struct
  sig {returns(::T.untyped)}
  def dsp_type(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def dsp_type=(_); end

  sig {returns(::T.untyped)}
  def param(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def param=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ContinuationRequest < Struct
  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def raw_data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::CramMD5Authenticator
  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  sig do
    params(
      challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(challenge); end
end

class Net::IMAP::DataFormatError < Net::IMAP::Error
end

class Net::IMAP::DigestMD5Authenticator
  STAGE_ONE = ::T.let(nil, ::T.untyped)
  STAGE_TWO = ::T.let(nil, ::T.untyped)

  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
      authname: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password, authname=T.unsafe(nil)); end

  sig do
    params(
      challenge: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(challenge); end
end

class Net::IMAP::Envelope < Struct
  sig {returns(::T.untyped)}
  def bcc(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def bcc=(_); end

  sig {returns(::T.untyped)}
  def cc(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def cc=(_); end

  sig {returns(::T.untyped)}
  def date(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def date=(_); end

  sig {returns(::T.untyped)}
  def from(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def from=(_); end

  sig {returns(::T.untyped)}
  def in_reply_to(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def in_reply_to=(_); end

  sig {returns(::T.untyped)}
  def message_id(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def message_id=(_); end

  sig {returns(::T.untyped)}
  def reply_to(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def reply_to=(_); end

  sig {returns(::T.untyped)}
  def sender(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sender=(_); end

  sig {returns(::T.untyped)}
  def subject(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def subject=(_); end

  sig {returns(::T.untyped)}
  def to(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def to=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::Error < StandardError
end

class Net::IMAP::FetchData < Struct
  sig {returns(::T.untyped)}
  def attr(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  sig {returns(::T.untyped)}
  def seqno(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seqno=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::FlagCountError < Net::IMAP::Error
end

class Net::IMAP::Literal
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::LoginAuthenticator
  STATE_PASSWORD = ::T.let(nil, ::T.untyped)
  STATE_USER = ::T.let(nil, ::T.untyped)

  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(data); end
end

class Net::IMAP::MailboxACLItem < Struct
  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def rights(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rights=(_); end

  sig {returns(::T.untyped)}
  def user(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def user=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MailboxList < Struct
  sig {returns(::T.untyped)}
  def attr(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  sig {returns(::T.untyped)}
  def delim(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def delim=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MailboxQuota < Struct
  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def quota(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def quota=(_); end

  sig {returns(::T.untyped)}
  def usage(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def usage=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MailboxQuotaRoot < Struct
  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig {returns(::T.untyped)}
  def quotaroots(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def quotaroots=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::MessageSet
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::NoResponseError < Net::IMAP::ResponseError
end

module Net::IMAP::NumValidator
  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ensure_number(num); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.ensure_nz_number(num); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid_number?(num); end

  sig do
    params(
      num: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.valid_nz_number?(num); end
end

class Net::IMAP::PlainAuthenticator
  sig do
    params(
      user: ::T.untyped,
      password: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(user, password); end

  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def process(data); end
end

class Net::IMAP::QuotedString
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::RawData
  sig do
    params(
      data: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(data); end

  sig do
    params(
      imap: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_data(imap); end

  sig {returns(::T.untyped)}
  def validate(); end
end

class Net::IMAP::ResponseCode < Struct
  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ResponseError < Net::IMAP::Error
  sig do
    params(
      response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(response); end

  sig {returns(::T.untyped)}
  def response(); end

  sig do
    params(
      response: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def response=(response); end
end

class Net::IMAP::ResponseParseError < Net::IMAP::Error
end

class Net::IMAP::ResponseParser
  ADDRESS_REGEXP = ::T.let(nil, ::T.untyped)
  ATOM_TOKENS = ::T.let(nil, ::T.untyped)
  BEG_REGEXP = ::T.let(nil, ::T.untyped)
  CTEXT_REGEXP = ::T.let(nil, ::T.untyped)
  DATA_REGEXP = ::T.let(nil, ::T.untyped)
  EXPR_BEG = ::T.let(nil, ::T.untyped)
  EXPR_CTEXT = ::T.let(nil, ::T.untyped)
  EXPR_DATA = ::T.let(nil, ::T.untyped)
  EXPR_RTEXT = ::T.let(nil, ::T.untyped)
  EXPR_TEXT = ::T.let(nil, ::T.untyped)
  FLAG_REGEXP = ::T.let(nil, ::T.untyped)
  RTEXT_REGEXP = ::T.let(nil, ::T.untyped)
  STRING_TOKENS = ::T.let(nil, ::T.untyped)
  TEXT_REGEXP = ::T.let(nil, ::T.untyped)
  T_ATOM = ::T.let(nil, ::T.untyped)
  T_BSLASH = ::T.let(nil, ::T.untyped)
  T_CRLF = ::T.let(nil, ::T.untyped)
  T_EOF = ::T.let(nil, ::T.untyped)
  T_LBRA = ::T.let(nil, ::T.untyped)
  T_LITERAL = ::T.let(nil, ::T.untyped)
  T_LPAR = ::T.let(nil, ::T.untyped)
  T_NIL = ::T.let(nil, ::T.untyped)
  T_NUMBER = ::T.let(nil, ::T.untyped)
  T_PERCENT = ::T.let(nil, ::T.untyped)
  T_PLUS = ::T.let(nil, ::T.untyped)
  T_QUOTED = ::T.let(nil, ::T.untyped)
  T_RBRA = ::T.let(nil, ::T.untyped)
  T_RPAR = ::T.let(nil, ::T.untyped)
  T_SPACE = ::T.let(nil, ::T.untyped)
  T_STAR = ::T.let(nil, ::T.untyped)
  T_TEXT = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def initialize(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def parse(str); end
end

class Net::IMAP::ResponseParser::Token < Struct
  sig {returns(::T.untyped)}
  def symbol(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def symbol=(_); end

  sig {returns(::T.untyped)}
  def value(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def value=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ResponseText < Struct
  sig {returns(::T.untyped)}
  def code(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def code=(_); end

  sig {returns(::T.untyped)}
  def text(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def text=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::StatusData < Struct
  sig {returns(::T.untyped)}
  def attr(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def attr=(_); end

  sig {returns(::T.untyped)}
  def mailbox(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailbox=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::TaggedResponse < Struct
  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig {returns(::T.untyped)}
  def raw_data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  sig {returns(::T.untyped)}
  def tag(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def tag=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::ThreadMember < Struct
  sig {returns(::T.untyped)}
  def children(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def children=(_); end

  sig {returns(::T.untyped)}
  def seqno(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def seqno=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::IMAP::UntaggedResponse < Struct
  sig {returns(::T.untyped)}
  def data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data=(_); end

  sig {returns(::T.untyped)}
  def name(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def name=(_); end

  sig {returns(::T.untyped)}
  def raw_data(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def raw_data=(_); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.[](*_); end

  sig {returns(::T.untyped)}
  def self.members(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.new(*_); end
end

class Net::InternetMessageIO < Net::BufferedIO
  sig {returns(::T.untyped)}
  def each_list_item(); end

  sig {returns(::T.untyped)}
  def each_message_chunk(); end

  sig do
    params(
      _: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(*_); end

  sig do
    params(
      src: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message(src); end

  sig do
    params(
      src: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message_0(src); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write_message_by_block(&block); end
end

module Net::NetPrivate
end

class Net::OpenTimeout < Timeout::Error
end

class Net::ProtoAuthError < Net::ProtocolError
end

class Net::ProtoCommandError < Net::ProtocolError
end

class Net::ProtoFatalError < Net::ProtocolError
end

class Net::ProtoRetriableError < Net::ProtocolError
end

class Net::ProtoServerError < Net::ProtocolError
end

class Net::ProtoSyntaxError < Net::ProtocolError
end

class Net::ProtoUnknownError < Net::ProtocolError
end

class Net::Protocol
  sig do
    params(
      name: ::T.untyped,
      val: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.protocol_param(name, val); end
end

class Net::ProtocolError < StandardError
end

class Net::ReadAdapter
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  sig do
    params(
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(block); end

  sig {returns(::T.untyped)}
  def inspect(); end
end

class Net::ReadTimeout < Timeout::Error
end

class Net::SMTP < Net::Protocol
  CRAM_BUFSIZE = ::T.let(nil, ::T.untyped)
  DEFAULT_AUTH_TYPE = ::T.let(nil, ::T.untyped)
  IMASK = ::T.let(nil, ::T.untyped)
  OMASK = ::T.let(nil, ::T.untyped)
  Revision = ::T.let(nil, ::T.untyped)

  sig {returns(::T.untyped)}
  def address(); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_cram_md5(user, secret); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_login(user, secret); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def auth_plain(user, secret); end

  sig do
    params(
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def authenticate(user, secret, authtype=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def capable_auth_types(); end

  sig {returns(::T.untyped)}
  def capable_cram_md5_auth?(); end

  sig {returns(::T.untyped)}
  def capable_login_auth?(); end

  sig {returns(::T.untyped)}
  def capable_plain_auth?(); end

  sig {returns(::T.untyped)}
  def capable_starttls?(); end

  sig do
    params(
      msgstr: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def data(msgstr=T.unsafe(nil), &block); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def debug_output=(arg); end

  sig {returns(::T.untyped)}
  def disable_ssl(); end

  sig {returns(::T.untyped)}
  def disable_starttls(); end

  sig {returns(::T.untyped)}
  def disable_tls(); end

  sig do
    params(
      domain: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ehlo(domain); end

  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_ssl(context=T.unsafe(nil)); end

  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_starttls(context=T.unsafe(nil)); end

  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_starttls_auto(context=T.unsafe(nil)); end

  sig do
    params(
      context: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def enable_tls(context=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def esmtp(); end

  sig do
    params(
      esmtp: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def esmtp=(esmtp); end

  sig {returns(::T.untyped)}
  def esmtp?(); end

  sig {returns(::T.untyped)}
  def finish(); end

  sig do
    params(
      domain: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def helo(domain); end

  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(address, port=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig do
    params(
      from_addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def mailfrom(from_addr); end

  sig do
    params(
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_message_stream(from_addr, *to_addrs, &block); end

  sig {returns(::T.untyped)}
  def open_timeout(); end

  sig do
    params(
      open_timeout: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def open_timeout=(open_timeout); end

  sig {returns(::T.untyped)}
  def port(); end

  sig {returns(::T.untyped)}
  def quit(); end

  sig do
    params(
      to_addr: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rcptto(to_addr); end

  sig do
    params(
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def rcptto_list(to_addrs); end

  sig {returns(::T.untyped)}
  def read_timeout(); end

  sig do
    params(
      sec: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def read_timeout=(sec); end

  sig do
    params(
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def ready(from_addr, *to_addrs, &block); end

  sig {returns(::T.untyped)}
  def rset(); end

  sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_mail(msgstr, from_addr, *to_addrs); end

  sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def send_message(msgstr, from_addr, *to_addrs); end

  sig do
    params(
      msgstr: ::T.untyped,
      from_addr: ::T.untyped,
      to_addrs: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def sendmail(msgstr, from_addr, *to_addrs); end

  sig do
    params(
      arg: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def set_debug_output(arg); end

  sig {returns(::T.untyped)}
  def ssl?(); end

  sig do
    params(
      helo: ::T.untyped,
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def start(helo=T.unsafe(nil), user=T.unsafe(nil), secret=T.unsafe(nil), authtype=T.unsafe(nil)); end

  sig {returns(::T.untyped)}
  def started?(); end

  sig {returns(::T.untyped)}
  def starttls(); end

  sig {returns(::T.untyped)}
  def starttls?(); end

  sig {returns(::T.untyped)}
  def starttls_always?(); end

  sig {returns(::T.untyped)}
  def starttls_auto?(); end

  sig {returns(::T.untyped)}
  def tls?(); end

  sig {returns(::T.untyped)}
  def self.default_port(); end

  sig {returns(::T.untyped)}
  def self.default_ssl_context(); end

  sig {returns(::T.untyped)}
  def self.default_ssl_port(); end

  sig {returns(::T.untyped)}
  def self.default_submission_port(); end

  sig {returns(::T.untyped)}
  def self.default_tls_port(); end

  sig do
    params(
      address: ::T.untyped,
      port: ::T.untyped,
      helo: ::T.untyped,
      user: ::T.untyped,
      secret: ::T.untyped,
      authtype: ::T.untyped,
      block: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.start(address, port=T.unsafe(nil), helo=T.unsafe(nil), user=T.unsafe(nil), secret=T.unsafe(nil), authtype=T.unsafe(nil), &block); end
end

class Net::SMTP::Response
  sig {returns(::T.untyped)}
  def capabilities(); end

  sig {returns(::T.untyped)}
  def continue?(); end

  sig {returns(::T.untyped)}
  def cram_md5_challenge(); end

  sig {returns(::T.untyped)}
  def exception_class(); end

  sig do
    params(
      status: ::T.untyped,
      string: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(status, string); end

  sig {returns(::T.untyped)}
  def message(); end

  sig {returns(::T.untyped)}
  def status(); end

  sig {returns(::T.untyped)}
  def status_type_char(); end

  sig {returns(::T.untyped)}
  def string(); end

  sig {returns(::T.untyped)}
  def success?(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def self.parse(str); end
end

class Net::SMTPAuthenticationError < Net::ProtoAuthError
  include ::Net::SMTPError
end

module Net::SMTPError
end

class Net::SMTPFatalError < Net::ProtoFatalError
  include ::Net::SMTPError
end

class Net::SMTPServerBusy < Net::ProtoServerError
  include ::Net::SMTPError
end

class Net::SMTPSyntaxError < Net::ProtoSyntaxError
  include ::Net::SMTPError
end

class Net::SMTPUnknownError < Net::ProtoUnknownError
  include ::Net::SMTPError
end

class Net::SMTPUnsupportedCommand < Net::ProtocolError
  include ::Net::SMTPError
end

class Net::WriteAdapter
  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def <<(str); end

  sig do
    params(
      socket: ::T.untyped,
      method: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def initialize(socket, method); end

  sig {returns(::T.untyped)}
  def inspect(); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def print(str); end

  sig do
    params(
      args: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def printf(*args); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def puts(str=T.unsafe(nil)); end

  sig do
    params(
      str: ::T.untyped,
    )
    .returns(::T.untyped)
  end
  def write(str); end
end
