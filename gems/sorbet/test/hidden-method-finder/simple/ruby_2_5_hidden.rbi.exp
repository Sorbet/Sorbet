# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi hidden-definitions

# typed: autogenerated

class Array
  include ::JSON::Ext::Generator::GeneratorMethods::Array
  def shelljoin(); end

  def to_h(); end
end

class Array
  def self.try_convert(_); end
end

class BigDecimal
  def clone(); end
  EXCEPTION_NaN = ::T.let(nil, ::T.untyped)
  VERSION = ::T.let(nil, ::T.untyped)
end

class BigDecimal
  def self.ver(); end
end

class Binding
  def clone(); end

  def irb(); end
end

module Bundler
  def self.original_exec(*args); end

  def self.original_system(*args); end

  def self.unbundled_env(); end

  def self.unbundled_exec(*args); end

  def self.unbundled_system(*args); end

  def self.with_unbundled_env(); end
end

class Class
  def json_creatable?(); end
end

class Delegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

module DidYouMean
  def self.formatter(); end

  def self.formatter=(formatter); end
end

class Dir
  def self.exists?(_); end
end

class ERB
  def def_method(mod, methodname, fname=T.unsafe(nil)); end

  def def_module(methodname=T.unsafe(nil)); end
end

class Encoding
  class Converter
    def initialize(*_); end
  # wrong constant name initialize
  end
  def _dump(*_); end
end

class Encoding
  def self._load(_); end
end

module Enumerable
  def sum(*_); end
end

class Enumerator
  class Generator
    def each(*_, &blk); end

    def initialize(*_); end
  # wrong constant name each
  # wrong constant name initialize
  end
  def each_with_index(); end
end

class ExitCalledError
end

class ExitCalledError
end

class FalseClass
  include ::JSON::Ext::Generator::GeneratorMethods::FalseClass
end

class File
  def self.exists?(_); end
end

module FileUtils
  module DryRun
    include ::FileUtils
    include StreamUtils_
    include LowMethods
  # uninitialized constant FileUtils::DryRun::VERSION
  # Did you mean?  FileUtils::DryRun::VERSION
  #                FileUtils::VERSION
  end

  module DryRun
    extend DryRun
    extend ::FileUtils
    extend StreamUtils_
    extend LowMethods
  end

  module NoWrite
    include ::FileUtils
    include StreamUtils_
    include LowMethods
  # uninitialized constant FileUtils::NoWrite::VERSION
  # Did you mean?  FileUtils::NoWrite::VERSION
  #                FileUtils::VERSION
  end

  module NoWrite
    extend NoWrite
    extend ::FileUtils
    extend StreamUtils_
    extend LowMethods
  end

  module Verbose
    include ::FileUtils
    include StreamUtils_
  # uninitialized constant FileUtils::Verbose::VERSION
  # Did you mean?  FileUtils::Verbose::VERSION
  #                FileUtils::VERSION
  end

  module Verbose
    extend Verbose
    extend ::FileUtils
    extend StreamUtils_
  end
  include StreamUtils_
end

module FileUtils
  extend StreamUtils_
end

class Float
  include ::JSON::Ext::Generator::GeneratorMethods::Float
end

class Foo
  def bar(); end

  def baz(); end
end

module GC
  def garbage_collect(*_); end
end

module Gem
  class Dependency
    def pretty_print(q); end
  # wrong constant name <=>
  # wrong constant name pretty_print
  end

  class DependencyInstaller
    def _deprecated_gems_to_install(); end

    def add_found_dependencies(to_do, dependency_list); end

    def gather_dependencies(); end

    def gems_to_install(*args, &block); end
  # wrong constant name _deprecated_gems_to_install
  # wrong constant name add_found_dependencies
  # wrong constant name gather_dependencies
  # wrong constant name gems_to_install
  end

  Gem::DependencyResolver = Gem::Resolver

  class Licenses
    IDENTIFIERS = ::T.let(nil, ::T.untyped)
  end

  class List
    def pretty_print(q); end
  # wrong constant name pretty_print
  end

  class Package
    class DigestIO
      def digests(); end

      def initialize(io, digests); end

      def write(data); end
    # wrong constant name digests
    # wrong constant name initialize
    # wrong constant name write
    end

    class DigestIO
      def self.wrap(io, digests); end
    # wrong constant name <static-init>
    # wrong constant name wrap
    end

    class FileSource
      def initialize(path); end

      def path(); end

      def present?(); end

      def start(); end

      def with_read_io(&block); end

      def with_write_io(&block); end
    # wrong constant name initialize
    # wrong constant name path
    # wrong constant name present?
    # wrong constant name start
    # wrong constant name with_read_io
    # wrong constant name with_write_io
    end

    class FileSource
    # wrong constant name <static-init>
    end

    class IOSource
      def initialize(io); end

      def io(); end

      def path(); end

      def present?(); end

      def start(); end

      def with_read_io(); end

      def with_write_io(); end
    # wrong constant name initialize
    # wrong constant name io
    # wrong constant name path
    # wrong constant name present?
    # wrong constant name start
    # wrong constant name with_read_io
    # wrong constant name with_write_io
    end

    class IOSource
    # wrong constant name <static-init>
    end

    class Old
      def extract_files(destination_dir); end

      def file_list(io); end

      def read_until_dashes(io); end

      def skip_ruby(io); end
    # wrong constant name extract_files
    # wrong constant name file_list
    # wrong constant name read_until_dashes
    # wrong constant name skip_ruby
    end

    class Old
    # wrong constant name <static-init>
    end

    class Source
    end

    class Source
    # wrong constant name <static-init>
    end

    class TarHeader
      def ==(other); end

      def checksum(); end

      def devmajor(); end

      def devminor(); end

      def empty?(); end

      def gid(); end

      def gname(); end

      def initialize(vals); end

      def linkname(); end

      def magic(); end

      def mode(); end

      def mtime(); end

      def name(); end

      def prefix(); end

      def size(); end

      def typeflag(); end

      def uid(); end

      def uname(); end

      def update_checksum(); end

      def version(); end
    # wrong constant name ==
      FIELDS = ::T.let(nil, ::T.untyped)
      PACK_FORMAT = ::T.let(nil, ::T.untyped)
      UNPACK_FORMAT = ::T.let(nil, ::T.untyped)
    # wrong constant name checksum
    # wrong constant name devmajor
    # wrong constant name devminor
    # wrong constant name empty?
    # wrong constant name gid
    # wrong constant name gname
    # wrong constant name initialize
    # wrong constant name linkname
    # wrong constant name magic
    # wrong constant name mode
    # wrong constant name mtime
    # wrong constant name name
    # wrong constant name prefix
    # wrong constant name size
    # wrong constant name typeflag
    # wrong constant name uid
    # wrong constant name uname
    # wrong constant name update_checksum
    # wrong constant name version
    end

    class TarHeader
      def self.from(stream); end

      def self.strict_oct(str); end
    # wrong constant name <static-init>
    # wrong constant name from
    # wrong constant name strict_oct
    end

    class TarReader
      def self.new(io); end
    # wrong constant name new
    end

    class TarWriter
      def self.new(io); end
    # wrong constant name new
    end
    def realpath(file); end
  # wrong constant name <Class:DigestIO>
  # wrong constant name <Class:FileSource>
  # wrong constant name <Class:IOSource>
  # wrong constant name <Class:Old>
  # wrong constant name <Class:Source>
  # wrong constant name <Class:TarHeader>
  # wrong constant name realpath
  end

  class Package
    def self.new(gem, security_policy=T.unsafe(nil)); end
  # wrong constant name new
  end

  class PathSupport
    def home(); end

    def initialize(env); end

    def path(); end

    def spec_cache_dir(); end
  # wrong constant name home
  # wrong constant name initialize
  # wrong constant name path
  # wrong constant name spec_cache_dir
  end

  class RemoteFetcher
    class FetchError
      def initialize(message, uri); end

      def uri(); end

      def uri=(uri); end
    # wrong constant name initialize
    # wrong constant name uri
    # wrong constant name uri=
    end

    class FetchError
    # wrong constant name <static-init>
    end

    class UnknownHostError
    end

    class UnknownHostError
    # wrong constant name <static-init>
    end
    def api_endpoint(uri); end

    def correct_for_windows_path(path); end

    def s3_expiration(); end

    def sign_s3_url(uri, expiration=T.unsafe(nil)); end
    BASE64_URI_TRANSLATE = ::T.let(nil, ::T.untyped)
  # wrong constant name <Class:FetchError>
  # wrong constant name <Class:UnknownHostError>
  # wrong constant name api_endpoint
  # wrong constant name correct_for_windows_path
  # wrong constant name s3_expiration
  # wrong constant name sign_s3_url
  end

  class Request
    extend UserInteraction
    extend DefaultUserInteraction
    extend Text
  end

  class RequestSet
    Gem::RequestSet::GemDepedencyAPI = Gem::RequestSet::GemDependencyAPI
    def pretty_print(q); end
  # wrong constant name pretty_print
  end

  class Requirement
    def pretty_print(q); end
  # wrong constant name pretty_print
  end

  class RuntimeRequirementNotMetError
    def suggestion(); end

    def suggestion=(suggestion); end
  # wrong constant name suggestion
  # wrong constant name suggestion=
  end

  class RuntimeRequirementNotMetError
  # wrong constant name <static-init>
  end

  # uninitialized constant Gem::S3URISigner
  # uninitialized constant Gem::S3URISigner
  class Source
    def api_uri(); end

    def pretty_print(q); end
  # wrong constant name <=>
  # wrong constant name api_uri
  # wrong constant name pretty_print
  end

  class SpecFetcher
    include UserInteraction
    include DefaultUserInteraction
    include Text
    def available_specs(type); end

    def detect(type=T.unsafe(nil)); end

    def initialize(sources=T.unsafe(nil)); end

    def latest_specs(); end

    def prerelease_specs(); end

    def search_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

    def sources(); end

    def spec_for_dependency(dependency, matching_platform=T.unsafe(nil)); end

    def specs(); end

    def suggest_gems_from_name(gem_name, type=T.unsafe(nil)); end

    def tuples_for(source, type, gracefully_ignore=T.unsafe(nil)); end
  # wrong constant name available_specs
  # wrong constant name detect
  # wrong constant name initialize
  # wrong constant name latest_specs
  # wrong constant name prerelease_specs
  # wrong constant name search_for_dependency
  # wrong constant name sources
  # wrong constant name spec_for_dependency
  # wrong constant name specs
  # wrong constant name suggest_gems_from_name
  # wrong constant name tuples_for
  end

  class SpecFetcher
    def self.fetcher(); end

    def self.fetcher=(fetcher); end
  # wrong constant name <static-init>
  # wrong constant name fetcher
  # wrong constant name fetcher=
  end

  class Specification
    include ::Bundler::MatchPlatform
    include ::Bundler::GemHelpers
    def bundled_gem_in_old_ruby?(); end

    def pretty_print(q); end

    def rubyforge_project(); end

    def to_ruby(); end

    def warning(statement); end
  # wrong constant name <=>
  # uninitialized constant Gem::Specification::GENERICS
  # Did you mean?  Gem::Specification::GENERICS
  # uninitialized constant Gem::Specification::GENERIC_CACHE
  # Did you mean?  Gem::Specification::GENERIC_CACHE
  # wrong constant name bundled_gem_in_old_ruby?
  # wrong constant name pretty_print
  # wrong constant name rubyforge_project
  # wrong constant name to_ruby
  # wrong constant name warning
  end

  class Specification
    extend ::Enumerable
    extend Deprecate
    def self.add_spec(spec); end

    def self.add_specs(*specs); end

    def self.remove_spec(spec); end
  # wrong constant name add_spec
  # wrong constant name add_specs
  # wrong constant name remove_spec
  end

  # uninitialized constant Gem::Stream
  # Did you mean?  Gem::StreamUI
  # uninitialized constant Gem::Stream
  # Did you mean?  Gem::StreamUI
  class StubSpecification
    class StubLine
      def extensions(); end

      def full_name(); end

      def initialize(data, extensions); end

      def name(); end

      def platform(); end

      def require_paths(); end

      def version(); end
    # wrong constant name extensions
    # wrong constant name full_name
    # wrong constant name initialize
    # wrong constant name name
    # wrong constant name platform
    # wrong constant name require_paths
    # wrong constant name version
    end
    def build_extensions(); end

    def extensions(); end

    def initialize(filename, base_dir, gems_dir, default_gem); end

    def missing_extensions?(); end

    def valid?(); end
  # wrong constant name build_extensions
  # wrong constant name extensions
  # wrong constant name initialize
  # wrong constant name missing_extensions?
  # wrong constant name valid?
  end

  class StubSpecification
    def self.default_gemspec_stub(filename, base_dir, gems_dir); end

    def self.gemspec_stub(filename, base_dir, gems_dir); end
  # wrong constant name default_gemspec_stub
  # wrong constant name gemspec_stub
  end

  Gem::UnsatisfiableDepedencyError = Gem::UnsatisfiableDependencyError

  # uninitialized constant Gem::UriParser
  # uninitialized constant Gem::UriParser
  # uninitialized constant Gem::UriParsing
  # uninitialized constant Gem::UriParsing
  module Util
    NULL_DEVICE = ::T.let(nil, ::T.untyped)
  end

  class Version
    Gem::Version::Requirement = Gem::Requirement
    def pretty_print(q); end
  # wrong constant name <=>
  # wrong constant name pretty_print
  end
  ConfigMap = ::T.let(nil, ::T.untyped)
  RbConfigPriorities = ::T.let(nil, ::T.untyped)
  RubyGemsPackageVersion = ::T.let(nil, ::T.untyped)
  RubyGemsVersion = ::T.let(nil, ::T.untyped)
  USE_BUNDLER_FOR_GEMDEPS = ::T.let(nil, ::T.untyped)
end

module Gem
  def self._deprecated_datadir(gem_name); end

  def self.default_gems_use_full_paths?(); end

  def self.remove_unresolved_default_spec(spec); end
end

class Hash
  include ::JSON::Ext::Generator::GeneratorMethods::Hash
end

class Hash
  def self.try_convert(_); end
end

class IO
  IO::EWOULDBLOCKWaitReadable = IO::EAGAINWaitReadable

  IO::EWOULDBLOCKWaitWritable = IO::EAGAINWaitWritable
  def nread(); end

  def pathconf(_); end

  def ready?(); end

  def wait(*_); end

  def wait_readable(*_); end

  def wait_writable(*_); end
end

class IPAddr
  def ==(other); end

  def initialize(addr=T.unsafe(nil), family=T.unsafe(nil)); end
end

class Integer
  include ::JSON::Ext::Generator::GeneratorMethods::Integer
end

module Kernel
  def itself(); end

  def object_id(); end

  def yield_self(); end
end

module Kernel
  def self.at_exit(); end
end

class KeyError
  include ::DidYouMean::Correctable
end

class Monitor
  def enter(); end

  def exit(); end

  def try_enter(); end
end

module MonitorMixin
  class ConditionVariable
    def initialize(monitor); end
  # wrong constant name initialize
  end
  def initialize(*args); end
  EXCEPTION_IMMEDIATE = ::T.let(nil, ::T.untyped)
  EXCEPTION_NEVER = ::T.let(nil, ::T.untyped)
end

class NameError
  include ::DidYouMean::Correctable
end

class NilClass
  include ::JSON::Ext::Generator::GeneratorMethods::NilClass
end

class Object
  include ::JSON::Ext::Generator::GeneratorMethods::Object
  ARGF = ::T.let(nil, ::T.untyped)
  ARGV = ::T.let(nil, ::T.untyped)
  CROSS_COMPILING = ::T.let(nil, ::T.untyped)
  ENV = ::T.let(nil, ::T.untyped)
  RUBY_COPYRIGHT = ::T.let(nil, ::T.untyped)
  RUBY_DESCRIPTION = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE = ::T.let(nil, ::T.untyped)
  RUBY_ENGINE_VERSION = ::T.let(nil, ::T.untyped)
  RUBY_PATCHLEVEL = ::T.let(nil, ::T.untyped)
  RUBY_PLATFORM = ::T.let(nil, ::T.untyped)
  RUBY_RELEASE_DATE = ::T.let(nil, ::T.untyped)
  RUBY_REVISION = ::T.let(nil, ::T.untyped)
  RUBY_VERSION = ::T.let(nil, ::T.untyped)
  STDERR = ::T.let(nil, ::T.untyped)
  STDIN = ::T.let(nil, ::T.untyped)
  STDOUT = ::T.let(nil, ::T.untyped)
  TOPLEVEL_BINDING = ::T.let(nil, ::T.untyped)
end

class Pathname
  def fnmatch?(*_); end

  def glob(*_); end

  def make_symlink(_); end
end

class Proc
  def clone(); end
end

module RbConfig
  def self.expand(val, config=T.unsafe(nil)); end

  def self.ruby(); end
end

class Set
  def ==(other); end

  def ===(o); end

  def compare_by_identity(); end

  def compare_by_identity?(); end

  def divide(&func); end

  def eql?(o); end

  def flatten_merge(set, seen=T.unsafe(nil)); end

  def pretty_print(pp); end

  def pretty_print_cycle(pp); end

  def reset(); end
  InspectKey = ::T.let(nil, ::T.untyped)
end

class SimpleDelegator
  RUBYGEMS_ACTIVATION_MONITOR = ::T.let(nil, ::T.untyped)
end

class Socket
  module Constants
    IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
    IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
    IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
  end
  IPV6_DONTFRAG = ::T.let(nil, ::T.untyped)
  IPV6_PATHMTU = ::T.let(nil, ::T.untyped)
  IPV6_RECVPATHMTU = ::T.let(nil, ::T.untyped)
end

class SortedSet
  def initialize(*args, &block); end
end

class SortedSet
  def self.setup(); end
end

class String
  include ::JSON::Ext::Generator::GeneratorMethods::String
  def shellescape(); end

  def shellsplit(); end
end

class String
  extend ::JSON::Ext::Generator::GeneratorMethods::String::Extend
end

class TrueClass
  include ::JSON::Ext::Generator::GeneratorMethods::TrueClass
end

module URI
  class FTP
    def self.new2(user, password, host, port, path, typecode=T.unsafe(nil), arg_check=T.unsafe(nil)); end
  # wrong constant name new2
  end

  class LDAP
    def attributes(); end

    def attributes=(val); end

    def dn(); end

    def dn=(val); end

    def extensions(); end

    def extensions=(val); end

    def filter(); end

    def filter=(val); end

    def initialize(*arg); end

    def scope(); end

    def scope=(val); end

    def set_attributes(val); end

    def set_dn(val); end

    def set_extensions(val); end

    def set_filter(val); end

    def set_scope(val); end
  # wrong constant name attributes
  # wrong constant name attributes=
  # wrong constant name dn
  # wrong constant name dn=
  # wrong constant name extensions
  # wrong constant name extensions=
  # wrong constant name filter
  # wrong constant name filter=
  # wrong constant name initialize
  # wrong constant name scope
  # wrong constant name scope=
  # wrong constant name set_attributes
  # wrong constant name set_dn
  # wrong constant name set_extensions
  # wrong constant name set_filter
  # wrong constant name set_scope
  end

  class MailTo
    def initialize(*arg); end
  # wrong constant name initialize
  end

  URI::Parser = URI::RFC2396_Parser

  URI::REGEXP = URI::RFC2396_REGEXP

  class RFC2396_Parser
    def initialize(opts=T.unsafe(nil)); end
  # wrong constant name initialize
  end

  class RFC3986_Parser
    def join(*uris); end

    def parse(uri); end

    def regexp(); end

    def split(uri); end
    RFC3986_relative_ref = ::T.let(nil, ::T.untyped)
  # wrong constant name join
  # wrong constant name parse
  # wrong constant name regexp
  # wrong constant name split
  end

  module Util
    def self.make_components_hash(klass, array_hash); end
  # wrong constant name make_components_hash
  end
  include RFC2396_REGEXP
end

module URI
  extend Escape
  def self.get_encoding(label); end
end

module UnicodeNormalize
end

module UnicodeNormalize
end

module Warning
  extend ::Warning
end

